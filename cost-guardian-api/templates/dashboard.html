<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <title>Cost Guardian Dashboard</title>
    <style>
        /* Auth modal styles */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .auth-modal {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 400px;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .auth-modal h2 {
            margin-top: 0;
            color: #333;
        }
        .auth-modal input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .auth-modal input[type="password"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 3px rgba(0, 124, 186, 0.1);
        }
        .auth-modal label {
            display: block;
            margin: 1rem 0 0.5rem;
            color: #555;
        }
        .auth-modal .checkbox-row {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        .auth-modal .checkbox-row input {
            margin-right: 0.5rem;
        }
        .auth-modal .buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        .auth-modal button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }
        .auth-modal .btn-primary {
            background: #007cba;
            color: white;
        }
        .auth-modal .btn-primary:hover {
            background: #005a87;
        }
        .auth-modal .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .auth-modal .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }
        .auth-modal .btn-secondary:hover {
            background: #e0e0e0;
        }
        .auth-error {
            color: #d32f2f;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        .hidden {
            display: none !important;
        }
        /* Auth status footer */
        /* Tracking Tokens section styles */
        .tracking-tokens-section {
            background: #f0f8ff;
            border: 1px solid #007cba;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .tracking-tokens-section h2 {
            margin-top: 0;
            color: #005a87;
            font-size: 1.2rem;
        }
        .section-description {
            color: #666;
            font-size: 0.9rem;
            margin: 0.5rem 0 1rem 0;
            font-style: italic;
        }
        .add-token-form {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .add-token-form input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 0.5rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .add-token-form input[type="text"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 3px rgba(0, 124, 186, 0.1);
        }
        .tokens-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .token-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .token-info {
            flex: 1;
            min-width: 200px;
        }
        .token-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 0.25rem;
        }
        .token-value {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #666;
            word-break: break-all;
        }
        .token-meta {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.25rem;
        }
        .token-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .token-status {
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        .token-status.active {
            background: #d4edda;
            color: #155724;
        }
        .token-status.inactive {
            background: #f8d7da;
            color: #721c24;
        }
        .tokens-message {
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        .tokens-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .tokens-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .no-tokens {
            color: #666;
            font-style: italic;
            padding: 1rem;
            text-align: center;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .btn-primary, .btn-secondary, .btn-danger {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .btn-primary {
            background: #007cba;
            color: white;
        }
        .btn-primary:hover {
            background: #005a87;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }

        
        .auth-status {
            margin-top: 2rem;
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #666;
        }
        .auth-status .key-display {
            font-family: monospace;
            color: #333;
        }
        .auth-status .sign-out {
            color: #007cba;
            cursor: pointer;
            text-decoration: underline;
        }
        .auth-status .sign-out:hover {
            color: #005a87;
        }
        /* Loading and disabled states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .status-message {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 4px;
            font-weight: bold;
        }
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
        }
        .status-error {
            background: #ffebee;
            color: #d32f2f;
        }

        /* Usage snippets modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }
        .modal-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.3rem;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .modal-close:hover {
            background: #e0e0e0;
        }
        .modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }
        .tab-button {
            flex: 1;
            padding: 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            color: #666;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .tab-button:hover {
            background: #e9ecef;
        }
        .tab-button.active {
            color: #007cba;
            border-bottom-color: #007cba;
            background: white;
        }
        .tab-content {
            display: none;
            padding: 1.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .snippet-description {
            margin-bottom: 1rem;
            color: #666;
            line-height: 1.4;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            margin: 1rem 0;
            position: relative;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .copy-code-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.8;
        }
        .copy-code-btn:hover {
            opacity: 1;
            background: #005a87;
        }
        .snippet-notes {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 0.9rem;
        }
        .snippet-notes strong {
            color: #1976d2;
        }
        .snippet-section {
            margin-bottom: 2rem;
        }
        .snippet-section h4 {
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        /* Data filters styles */
        .filters {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }
        .filters .group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .filters label {
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        .filters select, .filters input[type="date"] {
            padding: 0.4rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .filters select:focus, .filters input[type="date"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.1);
        }
        #custom-date-wrap {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .spinner-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .spinner {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid #ccc;
            border-top: 2px solid #007cba;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
        .table-message {
            text-align: center;
            color: #555;
            padding: 12px;
        }
        .table-message.error {
            color: #b00020;
        }
        .table-message.empty {
            color: #666;
            font-style: italic;
        }
        .controls-disabled {
            opacity: 0.6;
            pointer-events: none;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body data-require-signin="{{ 'true' if require_signin else 'false' }}">
    <!-- Auth Modal -->
    <div id="auth-overlay" class="auth-overlay hidden">
        <div class="auth-modal">
            <h2>üîë API Authentication</h2>
            <form id="auth-form">
                <label for="api-key-input">API Key</label>
                <input 
                    type="password" 
                    id="api-key-input" 
                    placeholder="Enter your API key..."
                    required
                    autocomplete="off"
                    autocapitalize="off"
                    spellcheck="false"
                >
                <div class="checkbox-row">
                    <input type="checkbox" id="remember-key">
                    <label for="remember-key">Remember on this device</label>
                </div>
                <div id="auth-error" class="auth-error hidden"></div>
                <div class="buttons">
                    <button type="button" id="cancel-btn" class="btn-secondary">Cancel</button>
                    <button type="submit" id="signin-btn" class="btn-primary">Sign In</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Usage Snippets Modal -->
    <div id="snippets-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h3>üìù Usage Examples</h3>
                <button class="modal-close" onclick="closeSnippetsModal()">&times;</button>
            </div>
            <div class="modal-content">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('curl')">cURL</button>
                    <button class="tab-button" onclick="switchTab('python')">Python</button>
                    <button class="tab-button" onclick="switchTab('nodejs')">Node.js</button>
                </div>
                
                <div id="curl-tab" class="tab-content active">
                    <div class="snippet-description">
                        Send usage data to Cost Guardian using cURL from your command line or shell scripts.
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Basic Usage</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="curl-basic">curl -X POST "${window.location.origin}/ingest" \
  -H "Content-Type: application/json" \
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \
  -d '{
    "tracking_token": "TRACKING_TOKEN",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "cost_usd": 0.002250
  }'</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>With Event ID (Idempotency)</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="curl-idempotent">curl -X POST "${window.location.origin}/ingest" \
  -H "Content-Type: application/json" \
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \
  -d '{
    "tracking_token": "TRACKING_TOKEN",
    "event_id": "unique-event-123",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150,
    "cost_usd": 0.002250,
    "timestamp": "2024-01-15T10:30:00Z"
  }'</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Note:</strong> Replace <code>YOUR_INGEST_KEY</code> with your server's ingest key and <code>TRACKING_TOKEN</code> with the token for this project.
                    </div>
                </div>

                <div id="python-tab" class="tab-content">
                    <div class="snippet-description">
                        Integrate Cost Guardian into your Python applications. Choose from basic integration or the decorator pattern that wraps existing OpenAI functions.
                    </div>

                    <div class="snippet-section">
                        <h4>Environment Configuration</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre># Add to your .env file
CG_BASE_URL=${window.location.origin}
CG_INGEST_KEY=YOUR_INGEST_KEY  
CG_TRACKING_TOKEN=TRACKING_TOKEN
CG_DEBUG=false  # Set to true for development debugging</pre>
                        </div>
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Decorator Pattern (Recommended)</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="python-decorator"># ---- cost_guardian_snippet.py (paste anywhere in your codebase) ----
import os, uuid, time, requests, functools, inspect, threading
from datetime import datetime, timezone

CG_BASE_URL       = os.getenv("CG_BASE_URL", "${window.location.origin}")
CG_INGEST_KEY     = os.getenv("CG_INGEST_KEY", "YOUR_INGEST_KEY")
CG_TRACKING_TOKEN = os.getenv("CG_TRACKING_TOKEN", "TRACKING_TOKEN")
CG_DEBUG          = os.getenv("CG_DEBUG", "false").lower() == "true"

def _iso_now():
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()

def _ingest_openai_usage(resp, model_hint=None):
    try:
        usage = getattr(resp, "usage", None) or (resp.get("usage") if isinstance(resp, dict) else {}) or {}
        pt = int(usage.get("prompt_tokens") or 0)
        ct = int(usage.get("completion_tokens") or 0)
        tt = int(usage.get("total_tokens") or (pt + ct))
        if tt == 0:
            if CG_DEBUG: print("[CG] skip ingest: no tokens")
            return

        model = getattr(resp, "model", None) or (resp.get("model") if isinstance(resp, dict) else None) or model_hint
        event_id = getattr(resp, "id", None) or (resp.get("id") if isinstance(resp, dict) else None) or str(uuid.uuid4())

        payload = {
            "tracking_token": CG_TRACKING_TOKEN,
            "provider": "openai",
            "model": model,
            "prompt_tokens": pt,
            "completion_tokens": ct,
            "total_tokens": tt,
            "timestamp": _iso_now(),
            "event_id": event_id,
        }

        for attempt in range(3):
            r = requests.post(
                f"{CG_BASE_URL}/ingest",
                headers={"Content-Type": "application/json", "X-Ingest-Key": CG_INGEST_KEY},
                json=payload,
                timeout=10,
            )
            if r.status_code in (200, 201):
                if CG_DEBUG: print("[CG] ingest ok", r.status_code)
                return
            if r.status_code not in (429, 500, 502, 503, 504):
                if CG_DEBUG: print("[CG] ingest fail", r.status_code, r.text)
                return
            delay = int(r.headers.get("Retry-After", attempt + 1))
            time.sleep(delay)
    except Exception as e:
        if CG_DEBUG: print("[CG] ingest exception:", e)

def track_cost(func):
    """
    Decorator for non-streaming OpenAI calls.
    Works with sync or async functions. Never throws.
    """
    if inspect.iscoroutinefunction(func):
        async def awrapper(*args, **kwargs):
            resp = await func(*args, **kwargs)
            # Don't block event loop: run ingestion in a background thread
            threading.Thread(target=_ingest_openai_usage, args=(resp, kwargs.get("model")), daemon=True).start()
            return resp
        return functools.wraps(func)(awrapper)
    else:
        @functools.wraps(func)
        def swrapper(*args, **kwargs):
            resp = func(*args, **kwargs)
            _ingest_openai_usage(resp, model_hint=kwargs.get("model"))
            return resp
        return swrapper</pre>
                        </div>
                        
                        <div class="snippet-notes">
                            <strong>Usage Example:</strong> Wrap your existing OpenAI functions with the decorator
                        </div>
                        
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="python-decorator-usage">from openai import OpenAI
from cost_guardian_snippet import track_cost

client = OpenAI()

@track_cost
def ask_heartbeat():
    return client.chat.completions.create(
        model="gpt-4o-mini-2024-07-18",
        messages=[{"role": "user", "content": "Say 'heartbeat'"}],
        max_tokens=5,
        temperature=0,
    )

# Works with async functions too
@track_cost
async def async_ask_heartbeat():
    return await client.chat.completions.create(
        model="gpt-4o-mini-2024-07-18",
        messages=[{"role": "user", "content": "Say 'heartbeat'"}],
        max_tokens=5,
        temperature=0,
    )

# Your existing code unchanged - just add the decorator
_ = ask_heartbeat()</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>Basic Integration</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="python-basic">import requests
import json
from datetime import datetime, timezone

def log_openai_usage(tracking_token, model, prompt_tokens, completion_tokens, event_id=None):
    """Log OpenAI usage to Cost Guardian"""
    
    payload = {
        "tracking_token": tracking_token,
        "provider": "openai",
        "model": model,
        "prompt_tokens": prompt_tokens,
        "completion_tokens": completion_tokens,
        "total_tokens": prompt_tokens + completion_tokens,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    if event_id:
        payload["event_id"] = event_id
    
    response = requests.post(
        "${window.location.origin}/ingest",
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": "YOUR_INGEST_KEY"
        },
        json=payload
    )
    
    if response.status_code == 201:
        print("Usage logged successfully")
    elif response.status_code == 200:
        result = response.json()
        if result.get("duplicate"):
            print("Duplicate event ignored (idempotency)")
    else:
        print(f"Error logging usage: {response.status_code} - {response.text}")

# Example usage
log_openai_usage(
    tracking_token="TRACKING_TOKEN",
    model="gpt-4o-mini-2024-07-18",
    prompt_tokens=100,
    completion_tokens=50,
    event_id="unique-event-123"  # Optional for idempotency
)</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Requirements:</strong> <code>pip install requests openai</code><br>
                        <strong>Note:</strong> Cost calculation is handled server-side. Set <code>CG_DEBUG=true</code> for development troubleshooting.
                    </div>
                </div>

                <div id="nodejs-tab" class="tab-content">
                    <div class="snippet-description">
                        Integrate Cost Guardian into your Node.js applications. Choose from basic integration or the wrapper function that works with existing OpenAI calls.
                    </div>

                    <div class="snippet-section">
                        <h4>Environment Configuration</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre># Add to your .env file
CG_BASE_URL=${window.location.origin}
CG_INGEST_KEY=YOUR_INGEST_KEY  
CG_TRACKING_TOKEN=TRACKING_TOKEN
CG_DEBUG=false  # Set to true for development debugging</pre>
                        </div>
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Wrapper Function (Recommended)</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="nodejs-wrapper">// ---- costGuardianSnippet.js ----
let fetchFn = globalThis.fetch;
if (!fetchFn) {
  try { fetchFn = require("node-fetch"); }
  catch { /* leave undefined; we'll warn in debug if used */ }
}

const { randomBytes, randomUUID: nodeRandomUUID } = require("node:crypto");
const genId = () =>
  (globalThis.crypto && globalThis.crypto.randomUUID)
    ? globalThis.crypto.randomUUID()
    : (nodeRandomUUID ? nodeRandomUUID() : randomBytes(16).toString("hex"));

const CG_BASE_URL = process.env.CG_BASE_URL || "${window.location.origin}";
const CG_INGEST_KEY = process.env.CG_INGEST_KEY || "YOUR_INGEST_KEY";
const CG_TRACKING_TOKEN = process.env.CG_TRACKING_TOKEN || "TRACKING_TOKEN";
const CG_DEBUG = String(process.env.CG_DEBUG || "false").toLowerCase() === "true";

async function ingestOpenAIUsage(resp, modelHint) {
  try {
    const usage = resp?.usage || {};
    const pt = Number(usage.prompt_tokens || 0);
    const ct = Number(usage.completion_tokens || 0);
    const tt = Number(usage.total_tokens || (pt + ct));
    if (!tt) { if (CG_DEBUG) console.warn("[CG] skip ingest: no tokens"); return; }

    const payload = {
      tracking_token: CG_TRACKING_TOKEN,
      provider: "openai",
      model: resp?.model || modelHint,
      prompt_tokens: pt,
      completion_tokens: ct,
      total_tokens: tt,
      timestamp: new Date().toISOString(),
      event_id: resp?.id || genId(),
    };

    if (!fetchFn) { if (CG_DEBUG) console.warn("[CG] fetch not available; install node-fetch"); return; }

    for (let a = 0; a < 3; a++) {
      const r = await fetchFn(`${CG_BASE_URL}/ingest`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Ingest-Key": CG_INGEST_KEY },
        body: JSON.stringify(payload),
      });
      if (r.status === 200 || r.status === 201) { if (CG_DEBUG) console.log("[CG] ingest ok", r.status); return; }
      if (![429, 500, 502, 503, 504].includes(r.status)) { if (CG_DEBUG) console.warn("[CG] ingest fail", r.status); return; }
      const ra = Number(r.headers.get("retry-after")) || (a + 1);
      await new Promise(res => setTimeout(res, ra * 1000));
    }
  } catch (e) {
    if (CG_DEBUG) console.warn("[CG] ingest exception:", e);
  }
}

// Drop-in wrapper for non-streaming Chat Completions
async function trackedChatCompletion(openai, createArgs) {
  const resp = await openai.chat.completions.create(createArgs);
  ingestOpenAIUsage(resp, createArgs?.model); // fire-and-forget
  return resp;
}

module.exports = { trackedChatCompletion };</pre>
                        </div>
                        
                        <div class="snippet-notes">
                            <strong>Usage Example:</strong> Replace your OpenAI calls with the wrapper function
                        </div>
                        
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="nodejs-wrapper-usage">const OpenAI = require("openai");
const { trackedChatCompletion } = require("./costGuardianSnippet");

const openai = new OpenAI();

// Instead of: openai.chat.completions.create(args)
// Use: trackedChatCompletion(openai, args)

(async () => {
  const response = await trackedChatCompletion(openai, {
    model: "gpt-4o-mini-2024-07-18",
    messages: [{ role: "user", content: "Say 'heartbeat'" }],
    max_tokens: 5,
    temperature: 0,
  });
  
  console.log(response.choices[0].message.content);
})();</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>Basic Integration</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="nodejs-basic">async function logOpenAIUsage(trackingToken, model, promptTokens, completionTokens, eventId = null) {
  const payload = {
    tracking_token: trackingToken,
    provider: "openai",
    model: model,
    prompt_tokens: promptTokens,
    completion_tokens: completionTokens,
    total_tokens: promptTokens + completionTokens,
    timestamp: new Date().toISOString()
  };

  if (eventId) {
    payload.event_id = eventId;
  }

  try {
    const response = await fetch("${window.location.origin}/ingest", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": "YOUR_INGEST_KEY"
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.status === 201) {
      console.log("Usage logged successfully");
    } else if (response.status === 200 && data.duplicate) {
      console.log("Duplicate event ignored (idempotency)");
    } else {
      console.error(`Error logging usage: ${response.status}`, data);
    }
  } catch (error) {
    console.error("Failed to log usage:", error);
  }
}

// Example usage
await logOpenAIUsage(
  "TRACKING_TOKEN",
  "gpt-4o-mini-2024-07-18",
  100,
  50,
  "unique-event-123"  // Optional for idempotency
);</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Requirements:</strong> <code>npm install openai</code> (for Node.js &lt; 18, also: <code>npm install node-fetch</code>)<br>
                        <strong>Note:</strong> Cost calculation is handled server-side. Set <code>CG_DEBUG=true</code> for development troubleshooting.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <h1>Cost Guardian Token Usage</h1>
    
    <!-- Loading/Status messages -->
    <div id="status-message" class="hidden"></div>
    
    <!-- Tracking Tokens Management Section -->
    <div class="tracking-tokens-section">
        <h2>üè∑Ô∏è Tracking Tokens</h2>
        <p class="section-description">Manage tracking tokens for client-push ingestion. Each token allows client applications to send usage data to the /ingest endpoint.</p>
        <div id="tokens-message" class="tokens-message hidden"></div>
        
        <form class="add-token-form" id="add-token-form">
            <input type="text" name="label" placeholder="Token label (e.g., 'Production App')" required maxlength="64">
            <button type="submit">Create Token</button>
        </form>
        
        <div class="tokens-list" id="tokens-list">
            <!-- Tokens will be populated here -->
        </div>
    </div>

    
    <button id="reset-btn" disabled>Reset Data</button>
    <p id="reset-status"></p>
    
    <!-- Data Filters -->
    <div class="filters" id="filters-container" aria-live="polite">
        <div class="group">
            <label for="range-select">Date Range:</label>
            <select id="range-select">
                <option value="today">Today</option>
                <option value="this_week">This Week</option>
                <option value="this_month" selected>This Month</option>
                <option value="custom">Custom</option>
            </select>
            <span id="custom-date-wrap" style="display:none;">
                <input type="date" id="start-date" aria-label="Start date">
                <input type="date" id="end-date" aria-label="End date">
                <button type="button" id="apply-filters" class="btn-primary">Apply</button>
            </span>
        </div>
        <div class="group">
            <label for="model-select">Model:</label>
            <select id="model-select">
                <option value="all" selected>All Models</option>
            </select>
        </div>
        <div class="group" id="token-filter-group" style="display:none;">
            <label for="token-select">Tracking Token:</label>
            <select id="token-select">
                <option value="">All Tokens</option>
            </select>
        </div>
        <div class="group">
            <button type="button" id="export-csv-btn" class="btn-secondary">Export CSV</button>
        </div>
        <div class="spinner-container" id="filter-spinner" style="display:none;">
            <span class="spinner" role="status" aria-label="Loading"></span>
            <span class="sr-only">Loading data...</span>
        </div>
    </div>
    
    <table border="1" id="usage-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Timestamp</th>
                <th>Model</th>
                <th>Prompt Tokens</th>
                <th>Completion Tokens</th>
                <th>Total Tokens</th>
                <th>Estimated Cost (USD)</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        <tfoot id="usage-totals">
            <tr>
                <td><strong>Totals</strong></td>
                <td></td>
                <td></td>
                <td id="sum-prompt"><strong>0</strong></td>
                <td id="sum-completion"><strong>0</strong></td>
                <td id="sum-total"><strong>0</strong></td>
                <td id="sum-cost"><strong>$0.0000</strong></td>
            </tr>
        </tfoot>
    </table>

    <!-- Auth Status Footer -->
    <div id="auth-status" class="auth-status hidden">
        <span>üîì Signed in as: <span id="key-display" class="key-display"></span></span>
        <span class="sign-out" id="sign-out-btn">Sign out</span>
    </div>

    <script>
        // Global state
        let authInProgress = false;
        let abortController = null;
        let currentRows = []; // Store current table data for CSV export
        let tokenCache = null; // Cache for tracking tokens
        const API_KEY_STORAGE = 'cg_api_key';

        // Storage helpers
        function getApiKey() {
            // Prefer sessionStorage over localStorage
            return sessionStorage.getItem(API_KEY_STORAGE) || 
                   localStorage.getItem(API_KEY_STORAGE) || '';
        }

        function setApiKey(key, remember = false) {
            if (remember) {
                localStorage.setItem(API_KEY_STORAGE, key);
                sessionStorage.removeItem(API_KEY_STORAGE);
            } else {
                sessionStorage.setItem(API_KEY_STORAGE, key);
                localStorage.removeItem(API_KEY_STORAGE);
            }
        }

        function clearApiKey() {
            sessionStorage.removeItem(API_KEY_STORAGE);
            localStorage.removeItem(API_KEY_STORAGE);
        }

        // UI helpers
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }

        function hideStatus() {
            const statusEl = document.getElementById('status-message');
            statusEl.className = 'status-message hidden';
        }

        function updateAuthStatus(key) {
            const statusEl = document.getElementById('auth-status');
            const keyDisplayEl = document.getElementById('key-display');
            
            if (key) {
                // Show masked key (last 4 chars)
                const masked = '‚Ä¢'.repeat(Math.max(0, key.length - 4)) + key.slice(-4);
                keyDisplayEl.textContent = masked;
                statusEl.classList.remove('hidden');
            } else {
                statusEl.classList.add('hidden');
            }
        }

        function showLogin(errorMessage = '') {
            if (authInProgress) return;
            
            const overlay = document.getElementById('auth-overlay');
            const errorEl = document.getElementById('auth-error');
            const inputEl = document.getElementById('api-key-input');
            
            if (errorMessage) {
                errorEl.textContent = errorMessage;
                errorEl.classList.remove('hidden');
            } else {
                errorEl.classList.add('hidden');
            }
            
            overlay.classList.remove('hidden');
            setTimeout(() => inputEl.focus(), 100);
        }

        function hideLogin() {
            const overlay = document.getElementById('auth-overlay');
            const errorEl = document.getElementById('auth-error');
            overlay.classList.add('hidden');
            errorEl.classList.add('hidden');
        }

        // CSV Export with security protections
        function exportCSV() {
            if (!currentRows || currentRows.length === 0) {
                alert('No data to export. Please ensure data is loaded.');
                return;
            }

            // CSV injection protection: prefix dangerous starting characters with '
            function sanitizeCSVField(field) {
                const str = String(field || '');
                if (str.startsWith('=') || str.startsWith('+') || str.startsWith('-') || str.startsWith('@')) {
                    return "'" + str;
                }
                return str;
            }

            // Escape CSV field (handle commas, quotes, newlines)
            function escapeCSVField(field) {
                const sanitized = sanitizeCSVField(field);
                if (sanitized.includes(',') || sanitized.includes('"') || sanitized.includes('\n')) {
                    return '"' + sanitized.replace(/"/g, '""') + '"';
                }
                return sanitized;
            }

            // Generate CSV content
            const headers = ['id', 'timestamp', 'model', 'promptTokens', 'completionTokens', 'totalTokens', 'estimatedCostUSD'];
            const csvRows = [headers.join(',')];

            currentRows.forEach(row => {
                const csvRow = headers.map(header => escapeCSVField(row[header])).join(',');
                csvRows.push(csvRow);
            });

            // Add UTF-8 BOM for Excel compatibility
            const csvContent = '\ufeff' + csvRows.join('\n');

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/[T:]/g, match => match === 'T' ? '-' : '');
            const filename = `cost-guardian-${timestamp}.csv`;
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(url);
        }

        // Simulate slow network for testing (respects localStorage setting)
        async function simulateSlowNetwork() {
            const slowMs = localStorage.getItem('cg.simulateSlowMs');
            if (slowMs && !isNaN(parseInt(slowMs))) {
                await new Promise(resolve => setTimeout(resolve, parseInt(slowMs)));
            }
        }

        // Enhanced fetch wrapper
        async function apiFetch(path, opts = {}) {
            // Simulate slow network if configured
            await simulateSlowNetwork();

            const headers = new Headers(opts.headers || {});
            const key = getApiKey();
            
            if (key) {
                headers.set('X-API-Key', key);
            }

            // Create & expose controller so Sign out can cancel
            const controller = opts.signal ? null : new AbortController();
            const signal = opts.signal || controller.signal;
            if (controller) abortController = controller;

            try {
                const response = await fetch(path, { 
                    ...opts, 
                    headers, 
                    signal 
                });

                // Handle 401 Unauthorized
                if (response.status === 401) {
                    if (!authInProgress) {
                        clearApiKey();
                        updateAuthStatus('');
                        showLogin('Unauthorized. Please enter your API key.');
                        authInProgress = true;
                    }
                    throw new Error('Unauthorized. Please sign in.');
                }

                // Handle 429 Rate Limited
                if (response.status === 429) {
                    const retryAfter = response.headers.get('Retry-After');
                    let message = 'Rate limited. Please retry.';
                    if (retryAfter) {
                        message += ` Try again in ${retryAfter}s.`;
                    }
                    throw new Error(message);
                }

                hideStatus();
                return response;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw error; // Re-throw abort errors
                }
                
                // Network errors
                if (!navigator.onLine) {
                    throw new Error('No internet connection. Please check your network.');
                }
                
                if (error.message.includes('Failed to fetch')) {
                    throw new Error('We couldn\'t load data. Please try again.');
                }
                
                // Re-throw other errors as-is
                throw error;
            } finally {
                // Clear reference so we don't accidentally abort later requests
                if (controller && abortController === controller) abortController = null;
            }
        }

        // Table rendering with totals
        function renderRows(rows) {
            const tableBody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            if (Array.isArray(rows)) {
                rows.forEach(row => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${row.id ?? ''}</td>
                        <td>${row.timestamp ?? ''}</td>
                        <td>${row.model ?? ''}</td>
                        <td>${row.promptTokens ?? ''}</td>
                        <td>${row.completionTokens ?? ''}</td>
                        <td>${row.totalTokens ?? ''}</td>
                        <td>${row.estimatedCostUSD ?? ''}</td>
                    `;
                    tableBody.appendChild(tr);
                });
            }
            
            // Update totals row
            renderTotals(computeTotals(rows));
        }

        function computeTotals(rows) {
            if (!Array.isArray(rows) || rows.length === 0) {
                return {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0,
                    estimatedCostUSD: 0
                };
            }
            
            return rows.reduce((totals, row) => {
                totals.promptTokens += parseFloat(row.promptTokens) || 0;
                totals.completionTokens += parseFloat(row.completionTokens) || 0;
                totals.totalTokens += parseFloat(row.totalTokens) || 0;
                totals.estimatedCostUSD += parseFloat(row.estimatedCostUSD) || 0;
                return totals;
            }, {
                promptTokens: 0,
                completionTokens: 0,
                totalTokens: 0,
                estimatedCostUSD: 0
            });
        }

        function renderTotals(totals) {
            const formatter = new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: 'USD', 
                minimumFractionDigits: 4 
            });
            
            document.getElementById('sum-prompt').innerHTML = `<strong>${totals.promptTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-completion').innerHTML = `<strong>${totals.completionTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-total').innerHTML = `<strong>${totals.totalTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-cost').innerHTML = `<strong>${formatter.format(totals.estimatedCostUSD)}</strong>`;
        }

        // Date and filtering helpers
        function toISOStartOfDay(dateStr) {
            return new Date(dateStr + 'T00:00:00Z').toISOString();
        }

        function toISOEndOfDay(dateStr) {
            return new Date(dateStr + 'T23:59:59Z').toISOString();
        }

        function computePresetRange(preset) {
            const now = new Date();
            const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            
            if (preset === 'today') {
                return { 
                    start: today.toISOString(), 
                    end: new Date(today.getTime() + 86399 * 1000).toISOString() 
                };
            }
            
            if (preset === 'this_week') {
                // ISO week: Monday start. Compute day (0=Sun..6=Sat); shift to Monday.
                const day = (today.getUTCDay() + 6) % 7;
                const monday = new Date(today.getTime() - day * 86400000);
                const sundayEnd = new Date(monday.getTime() + 6 * 86400000 + 86399 * 1000);
                return { start: monday.toISOString(), end: sundayEnd.toISOString() };
            }
            
            if (preset === 'this_month') {
                const first = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));
                const last = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() + 1, 0, 23, 59, 59));
                return { start: first.toISOString(), end: last.toISOString() };
            }
            
            return { start: null, end: null };
        }

        // Enhanced loading and error state management
        function setLoading(isLoading) {
            const filtersContainer = document.getElementById('filters-container');
            const resetBtn = document.getElementById('reset-btn');
            const exportBtn = document.getElementById('export-csv-btn');
            
            if (isLoading) {
                filtersContainer.classList.add('controls-disabled');
                resetBtn.disabled = true;
                exportBtn.disabled = true;
                renderSpinnerRow();
            } else {
                filtersContainer.classList.remove('controls-disabled');
                resetBtn.disabled = false;
                exportBtn.disabled = false;
            }
        }

        function renderSpinnerRow() {
            const tbody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            const colspan = document.getElementById('usage-table').getElementsByTagName('th').length;
            tbody.innerHTML = `<tr><td colspan="${colspan}" class="table-message">
                <span class="spinner" aria-hidden="true"></span>Loading‚Ä¶
            </td></tr>`;
        }

        function renderError(message) {
            const tbody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            const colspan = document.getElementById('usage-table').getElementsByTagName('th').length;
            tbody.innerHTML = `<tr><td colspan="${colspan}" class="table-message error">
                Couldn't load data: <span>${message}</span>
            </td></tr>`;
            // Zero out totals on error
            renderTotals(computeTotals([]));
        }

        function renderEmpty() {
            const tbody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            const colspan = document.getElementById('usage-table').getElementsByTagName('th').length;
            tbody.innerHTML = `<tr><td colspan="${colspan}" class="table-message empty">
                No data for the selected filters.
            </td></tr>`;
            // Zero out totals on empty
            renderTotals(computeTotals([]));
        }

        function renderTableMessage(text, type = 'info') {
            const tbody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            const colspan = document.getElementById('usage-table').getElementsByTagName('th').length;
            const cssClass = type === 'error' ? 'table-message error' : 'table-message';
            tbody.innerHTML = `<tr><td colspan="${colspan}" class="${cssClass}">${text}</td></tr>`;
        }

        function populateModelOptions(rows) {
            const select = document.getElementById('model-select');
            const current = select.value || 'all';
            const models = Array.from(new Set((rows || []).map(r => r.model).filter(Boolean))).sort();
            
            // Keep first option as "All Models"
            const opts = ['<option value="all">All Models</option>'].concat(
                models.map(m => `<option value="${m}">${m}</option>`)
            );
            select.innerHTML = opts.join('');
            
            // Try to preserve previous selection if still present
            if ([...select.options].some(o => o.value === current)) {
                select.value = current;
            }
        }

        // Enhanced data fetching with filters
        async function fetchData(filters = {}) {
            // Cancel previous request if still in flight
            if (abortController) {
                abortController.abort();
                abortController = null;
            }

            try {
                setLoading(true);
                hideStatus();

                const params = new URLSearchParams();
                if (filters.start) params.set('start', filters.start);
                if (filters.end) params.set('end', filters.end);
                if (filters.model && filters.model !== 'all') params.set('model', filters.model);
                if (filters.ingest_token_id) params.set('ingest_token_id', filters.ingest_token_id);

                const response = await apiFetch('/data' + (params.toString() ? `?${params}` : ''));
                
                // Check for server validation errors
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP ${response.status}`);
                }
                
                const payload = await response.json();
                const rows = Array.isArray(payload) ? payload : payload?.data;
                currentRows = rows || []; // Store for CSV export

                if (!rows || rows.length === 0) {
                    renderEmpty();
                    populateModelOptions(rows);
                    return;
                }

                renderRows(rows);
                populateModelOptions(rows);
                renderTotals(computeTotals(rows));
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    return; // Request was cancelled, ignore
                }
                
                console.error('Error loading data:', error);
                currentRows = []; // Clear data on error
                
                renderError(error.message);
                
            } finally {
                setLoading(false);
            }
        }

        // Auth form handling
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const submitBtn = document.getElementById('signin-btn');
            const apiKeyInput = document.getElementById('api-key-input');
            const rememberCheckbox = document.getElementById('remember-key');
            const errorEl = document.getElementById('auth-error');
            
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                errorEl.textContent = 'API key is required';
                errorEl.classList.remove('hidden');
                return;
            }
            
            // Set loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Signing in...';
            errorEl.classList.add('hidden');
            
            try {
                // Store key temporarily for test
                setApiKey(apiKey, rememberCheckbox.checked);
                
                // Test the key by fetching data
                await fetchData();
                
                // Success - hide modal and update UI
                hideLogin();
                updateAuthStatus(apiKey);
                authInProgress = false;
                
            } catch (error) {
                // Auth failed - clear key and show error
                clearApiKey();
                if (error.message === 'Unauthorized') {
                    errorEl.textContent = 'Invalid API key. Please check and try again.';
                } else {
                    errorEl.textContent = 'Authentication failed. Please try again.';
                }
                errorEl.classList.remove('hidden');
            } finally {
                // Reset button state
                submitBtn.disabled = false;
                submitBtn.textContent = 'Sign In';
            }
        });

        // Cancel/close modal
        document.getElementById('cancel-btn').addEventListener('click', () => {
            hideLogin();
            authInProgress = false;
        });

        // Sign out
        document.getElementById('sign-out-btn').addEventListener('click', () => {
            // Abort any in-flight requests
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            
            clearApiKey();
            updateAuthStatus('');
            document.getElementById('reset-btn').disabled = true;
            
            // Clear table
            renderRows([]);
            
            showLogin();
        });

        // Reset button with auth
        document.getElementById('reset-btn').addEventListener('click', async () => {
            if (!getApiKey()) {
                showLogin('Please sign in to reset data.');
                return;
            }
            
            const resetBtn = document.getElementById('reset-btn');
            const resetStatus = document.getElementById('reset-status');
            
            resetBtn.disabled = true;
            resetBtn.textContent = 'Resetting...';
            resetStatus.textContent = '';
            
            try {
                const response = await apiFetch('/reset', { method: 'DELETE' });
                const data = await response.json();
                resetStatus.textContent = data.message || 'Reset complete.';
                
                // Reload table after successful reset
                await fetchData();
                
            } catch (error) {
                resetStatus.textContent = 'Reset failed.';
                console.error('Error resetting data:', error);
            } finally {
                resetBtn.disabled = false;
                resetBtn.textContent = 'Reset Data';
            }
        });

        // Keyboard accessibility
        document.addEventListener('keydown', (e) => {
            const overlay = document.getElementById('auth-overlay');
            const isModalVisible = !overlay.classList.contains('hidden');
            
            if (e.key === 'Escape' && isModalVisible) {
                // Only close on escape if we don't require immediate auth
                const hasKey = getApiKey();
                if (hasKey || !authInProgress) {
                    hideLogin();
                    authInProgress = false;
                }
            }
        });


        // Tracking Tokens functionality
        async function fetchTrackingTokens() {
            try {
                const response = await apiFetch('/ingest/tokens');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                displayTrackingTokens(data.tokens);
            } catch (error) {
                console.error('Error fetching tracking tokens:', error);
                showTokensMessage('Failed to load tracking tokens', 'error');
            }
        }

        function displayTrackingTokens(tokens) {
            const listEl = document.getElementById('tokens-list');
            
            if (!tokens || tokens.length === 0) {
                listEl.innerHTML = '<p class="no-tokens">No tracking tokens found. Create one to start using client-push ingestion.</p>';
                return;
            }

            listEl.innerHTML = tokens.map(token => {
                const createdDate = new Date(token.created_at).toLocaleDateString();
                const lastSeenDate = token.last_seen_at ? new Date(token.last_seen_at).toLocaleString() : 'Never';
                const usageCount = token.usage_count || 0;
                
                return `
                    <div class="token-item">
                        <div class="token-info">
                            <div class="token-label">${escapeHtml(token.label)}</div>
                            <div class="token-value" onclick="copyToClipboard('${token.token}')" title="Click to copy">${token.token}</div>
                            <div class="token-meta">
                                Created: ${createdDate} | Last used: ${lastSeenDate} | Usage: ${usageCount} requests
                            </div>
                        </div>
                        <div class="token-actions">
                            <span class="token-status ${token.active ? 'active' : 'inactive'}">
                                ${token.active ? 'Active' : 'Inactive'}
                            </span>
                            <button onclick="copySnippet('${token.token}', '${escapeHtml(token.label)}')" class="btn-primary">
                                Copy Snippet
                            </button>
                            <button onclick="toggleToken(${token.id}, ${!token.active})" class="btn-secondary">
                                ${token.active ? 'Deactivate' : 'Activate'}
                            </button>
                            <button onclick="deleteToken(${token.id}, '${escapeHtml(token.label)}')" class="btn-danger">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function addTrackingToken(event) {
            event.preventDefault();
            const button = event.target.querySelector('button[type="submit"]');
            const formData = new FormData(event.target);
            const label = formData.get('label').trim();

            if (!label) {
                showTokensMessage('Label is required', 'error');
                return;
            }

            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Creating...';

            try {
                const response = await apiFetch('/ingest/tokens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ label })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                showTokensMessage(`Tracking token "${label}" created successfully!`, 'success');
                event.target.reset();
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error adding tracking token:', error);
                showTokensMessage(`Failed to create token: ${error.message}`, 'error');
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        async function toggleToken(tokenId, newActiveState) {
            try {
                const response = await apiFetch(`/ingest/tokens/${tokenId}/active`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ active: newActiveState })
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                const action = newActiveState ? 'activated' : 'deactivated';
                showTokensMessage(`Token ${action} successfully`, 'success');
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error toggling token:', error);
                showTokensMessage(`Failed to toggle token: ${error.message}`, 'error');
            }
        }

        async function deleteToken(tokenId, label) {
            if (!confirm(`Are you sure you want to delete the tracking token "${label}"? This action cannot be undone.`)) {
                return;
            }

            try {
                const response = await apiFetch(`/ingest/tokens/${tokenId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                showTokensMessage(`Token "${label}" deleted successfully`, 'success');
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error deleting token:', error);
                showTokensMessage(`Failed to delete token: ${error.message}`, 'error');
            }
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showTokensMessage('Token copied to clipboard!', 'success');
                }).catch(() => {
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }

        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                showTokensMessage('Token copied to clipboard!', 'success');
            } catch (err) {
                showTokensMessage('Failed to copy token', 'error');
            }
            document.body.removeChild(textArea);
        }

        function copySnippet(token, label) {
            openSnippetsModal(token, label);
        }

        function showTokensMessage(message, type = 'info') {
            const messageEl = document.getElementById('tokens-message');
            messageEl.textContent = message;
            messageEl.className = `tokens-message ${type}`;
            
            // Hide message after 5 seconds
            setTimeout(() => {
                messageEl.className = 'tokens-message hidden';
            }, 5000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Usage snippets modal functionality
        function openSnippetsModal(token, label) {
            const modal = document.getElementById('snippets-modal');
            
            // Replace placeholders with actual values in all code blocks
            updateSnippetContent(token);
            
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent background scroll
        }

        function closeSnippetsModal() {
            const modal = document.getElementById('snippets-modal');
            modal.classList.add('hidden');
            document.body.style.overflow = ''; // Restore scrolling
        }

        function switchTab(tabName) {
            // Update tab buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const activeButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (activeButton) activeButton.classList.add('active');
            
            // Update tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            const activeContent = document.getElementById(`${tabName}-tab`);
            if (activeContent) activeContent.classList.add('active');
        }

        function updateSnippetContent(token) {
            const baseUrl = window.location.origin;
            
            // Update cURL examples
            const curlBasic = document.getElementById('curl-basic');
            if (curlBasic) {
                curlBasic.textContent = `curl -X POST "${baseUrl}/ingest" \\
  -H "Content-Type: application/json" \\
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \\
  -d '{
    "tracking_token": "${token}",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "cost_usd": 0.002250
  }'`;
            }

            const curlIdempotent = document.getElementById('curl-idempotent');
            if (curlIdempotent) {
                curlIdempotent.textContent = `curl -X POST "${baseUrl}/ingest" \\
  -H "Content-Type: application/json" \\
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \\
  -d '{
    "tracking_token": "${token}",
    "event_id": "unique-event-123",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150,
    "cost_usd": 0.002250,
    "timestamp": "2024-01-15T10:30:00Z"
  }'`;
            }

            // Update Python examples
            const pythonDecorator = document.getElementById('python-decorator');
            if (pythonDecorator) {
                pythonDecorator.textContent = `# ---- cost_guardian_snippet.py (paste anywhere in your codebase) ----
import os, uuid, time, requests, functools, inspect, threading
from datetime import datetime, timezone

CG_BASE_URL       = os.getenv("CG_BASE_URL", "${baseUrl}")
CG_INGEST_KEY     = os.getenv("CG_INGEST_KEY", "YOUR_INGEST_KEY")
CG_TRACKING_TOKEN = os.getenv("CG_TRACKING_TOKEN", "${token}")
CG_DEBUG          = os.getenv("CG_DEBUG", "false").lower() == "true"

def _iso_now():
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()

def _ingest_openai_usage(resp, model_hint=None):
    try:
        usage = getattr(resp, "usage", None) or (resp.get("usage") if isinstance(resp, dict) else {}) or {}
        pt = int(usage.get("prompt_tokens") or 0)
        ct = int(usage.get("completion_tokens") or 0)
        tt = int(usage.get("total_tokens") or (pt + ct))
        if tt == 0:
            if CG_DEBUG: print("[CG] skip ingest: no tokens")
            return

        model = getattr(resp, "model", None) or (resp.get("model") if isinstance(resp, dict) else None) or model_hint
        event_id = getattr(resp, "id", None) or (resp.get("id") if isinstance(resp, dict) else None) or str(uuid.uuid4())

        payload = {
            "tracking_token": CG_TRACKING_TOKEN,
            "provider": "openai",
            "model": model,
            "prompt_tokens": pt,
            "completion_tokens": ct,
            "total_tokens": tt,
            "timestamp": _iso_now(),
            "event_id": event_id,
        }

        for attempt in range(3):
            r = requests.post(
                f"{CG_BASE_URL}/ingest",
                headers={"Content-Type": "application/json", "X-Ingest-Key": CG_INGEST_KEY},
                json=payload,
                timeout=10,
            )
            if r.status_code in (200, 201):
                if CG_DEBUG: print("[CG] ingest ok", r.status_code)
                return
            if r.status_code not in (429, 500, 502, 503, 504):
                if CG_DEBUG: print("[CG] ingest fail", r.status_code, r.text)
                return
            delay = int(r.headers.get("Retry-After", attempt + 1))
            time.sleep(delay)
    except Exception as e:
        if CG_DEBUG: print("[CG] ingest exception:", e)

def track_cost(func):
    """
    Decorator for non-streaming OpenAI calls.
    Works with sync or async functions. Never throws.
    """
    if inspect.iscoroutinefunction(func):
        async def awrapper(*args, **kwargs):
            resp = await func(*args, **kwargs)
            # Don't block event loop: run ingestion in a background thread
            threading.Thread(target=_ingest_openai_usage, args=(resp, kwargs.get("model")), daemon=True).start()
            return resp
        return functools.wraps(func)(awrapper)
    else:
        @functools.wraps(func)
        def swrapper(*args, **kwargs):
            resp = func(*args, **kwargs)
            _ingest_openai_usage(resp, model_hint=kwargs.get("model"))
            return resp
        return swrapper`;
            }

            const pythonDecoratorUsage = document.getElementById('python-decorator-usage');
            if (pythonDecoratorUsage) {
                pythonDecoratorUsage.textContent = `from openai import OpenAI
from cost_guardian_snippet import track_cost

client = OpenAI()

@track_cost
def ask_heartbeat():
    return client.chat.completions.create(
        model="gpt-4o-mini-2024-07-18",
        messages=[{"role": "user", "content": "Say 'heartbeat'"}],
        max_tokens=5,
        temperature=0,
    )

# Works with async functions too
@track_cost
async def async_ask_heartbeat():
    return await client.chat.completions.create(
        model="gpt-4o-mini-2024-07-18",
        messages=[{"role": "user", "content": "Say 'heartbeat'"}],
        max_tokens=5,
        temperature=0,
    )

# Your existing code unchanged - just add the decorator
_ = ask_heartbeat()`;
            }

            const pythonBasic = document.getElementById('python-basic');
            if (pythonBasic) {
                pythonBasic.textContent = `import requests
import json
from datetime import datetime, timezone

def log_openai_usage(tracking_token, model, prompt_tokens, completion_tokens, event_id=None):
    """Log OpenAI usage to Cost Guardian"""
    
    payload = {
        "tracking_token": tracking_token,
        "provider": "openai",
        "model": model,
        "prompt_tokens": prompt_tokens,
        "completion_tokens": completion_tokens,
        "total_tokens": prompt_tokens + completion_tokens,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    if event_id:
        payload["event_id"] = event_id
    
    response = requests.post(
        "${baseUrl}/ingest",
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": "YOUR_INGEST_KEY"
        },
        json=payload
    )
    
    if response.status_code == 201:
        print("Usage logged successfully")
    elif response.status_code == 200:
        result = response.json()
        if result.get("duplicate"):
            print("Duplicate event ignored (idempotency)")
    else:
        print(f"Error logging usage: {response.status_code} - {response.text}")

# Example usage
log_openai_usage(
    tracking_token="${token}",
    model="gpt-4o-mini-2024-07-18",
    prompt_tokens=100,
    completion_tokens=50,
    event_id="unique-event-123"  # Optional for idempotency
)`;
            }

            const pythonOpenai = document.getElementById('python-openai');
            if (pythonOpenai) {
                pythonOpenai.textContent = `import openai
import requests
from datetime import datetime, timezone

# Configure OpenAI and Cost Guardian
openai.api_key = "your-openai-api-key"
COST_GUARDIAN_URL = "${baseUrl}/ingest"
INGEST_KEY = "YOUR_INGEST_KEY"
TRACKING_TOKEN = "${token}"

def chat_with_logging(messages, model="gpt-4o-mini-2024-07-18"):
    """Make OpenAI chat completion and log usage to Cost Guardian"""
    
    # Make OpenAI request
    response = openai.chat.completions.create(
        model=model,
        messages=messages
    )
    
    # Extract usage information
    usage = response.usage
    
    # Log to Cost Guardian
    log_payload = {
        "tracking_token": TRACKING_TOKEN,
        "model": model,
        "prompt_tokens": usage.prompt_tokens,
        "completion_tokens": usage.completion_tokens,
        "total_tokens": usage.total_tokens,
        "cost_usd": calculate_cost(usage, model),  # Implement your cost calculation
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "event_id": response.id  # Use OpenAI response ID for idempotency
    }
    
    requests.post(
        COST_GUARDIAN_URL,
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": INGEST_KEY
        },
        json=log_payload
    )
    
    return response

def calculate_cost(usage, model):
    """Calculate cost based on OpenAI pricing"""
    # Example pricing for gpt-4o-mini-2024-07-18
    prompt_cost_per_1k = 0.000150
    completion_cost_per_1k = 0.000600
    
    prompt_cost = (usage.prompt_tokens / 1000) * prompt_cost_per_1k
    completion_cost = (usage.completion_tokens / 1000) * completion_cost_per_1k
    
    return prompt_cost + completion_cost`;
            }

            // Update Node.js examples
            const nodejsWrapper = document.getElementById('nodejs-wrapper');
            if (nodejsWrapper) {
                nodejsWrapper.textContent = `// ---- costGuardianSnippet.js ----
let fetchFn = globalThis.fetch;
if (!fetchFn) {
  try { fetchFn = require("node-fetch"); }
  catch { /* leave undefined; we'll warn in debug if used */ }
}

const { randomBytes, randomUUID: nodeRandomUUID } = require("node:crypto");
const genId = () =>
  (globalThis.crypto && globalThis.crypto.randomUUID)
    ? globalThis.crypto.randomUUID()
    : (nodeRandomUUID ? nodeRandomUUID() : randomBytes(16).toString("hex"));

const CG_BASE_URL = process.env.CG_BASE_URL || "${baseUrl}";
const CG_INGEST_KEY = process.env.CG_INGEST_KEY || "YOUR_INGEST_KEY";
const CG_TRACKING_TOKEN = process.env.CG_TRACKING_TOKEN || "${token}";
const CG_DEBUG = String(process.env.CG_DEBUG || "false").toLowerCase() === "true";

async function ingestOpenAIUsage(resp, modelHint) {
  try {
    const usage = resp?.usage || {};
    const pt = Number(usage.prompt_tokens || 0);
    const ct = Number(usage.completion_tokens || 0);
    const tt = Number(usage.total_tokens || (pt + ct));
    if (!tt) { if (CG_DEBUG) console.warn("[CG] skip ingest: no tokens"); return; }

    const payload = {
      tracking_token: CG_TRACKING_TOKEN,
      provider: "openai",
      model: resp?.model || modelHint,
      prompt_tokens: pt,
      completion_tokens: ct,
      total_tokens: tt,
      timestamp: new Date().toISOString(),
      event_id: resp?.id || genId(),
    };

    if (!fetchFn) { if (CG_DEBUG) console.warn("[CG] fetch not available; install node-fetch"); return; }

    for (let a = 0; a < 3; a++) {
      const r = await fetchFn(\`\${CG_BASE_URL}/ingest\`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Ingest-Key": CG_INGEST_KEY },
        body: JSON.stringify(payload),
      });
      if (r.status === 200 || r.status === 201) { if (CG_DEBUG) console.log("[CG] ingest ok", r.status); return; }
      if (![429, 500, 502, 503, 504].includes(r.status)) { if (CG_DEBUG) console.warn("[CG] ingest fail", r.status); return; }
      const ra = Number(r.headers.get("retry-after")) || (a + 1);
      await new Promise(res => setTimeout(res, ra * 1000));
    }
  } catch (e) {
    if (CG_DEBUG) console.warn("[CG] ingest exception:", e);
  }
}

// Drop-in wrapper for non-streaming Chat Completions
async function trackedChatCompletion(openai, createArgs) {
  const resp = await openai.chat.completions.create(createArgs);
  ingestOpenAIUsage(resp, createArgs?.model); // fire-and-forget
  return resp;
}

module.exports = { trackedChatCompletion };`;
            }

            const nodejsWrapperUsage = document.getElementById('nodejs-wrapper-usage');
            if (nodejsWrapperUsage) {
                nodejsWrapperUsage.textContent = `const OpenAI = require("openai");
const { trackedChatCompletion } = require("./costGuardianSnippet");

const openai = new OpenAI();

// Instead of: openai.chat.completions.create(args)
// Use: trackedChatCompletion(openai, args)

(async () => {
  const response = await trackedChatCompletion(openai, {
    model: "gpt-4o-mini-2024-07-18",
    messages: [{ role: "user", content: "Say 'heartbeat'" }],
    max_tokens: 5,
    temperature: 0,
  });
  
  console.log(response.choices[0].message.content);
})();`;
            }

            const nodejsBasic = document.getElementById('nodejs-basic');
            if (nodejsBasic) {
                nodejsBasic.textContent = `async function logOpenAIUsage(trackingToken, model, promptTokens, completionTokens, eventId = null) {
  const payload = {
    tracking_token: trackingToken,
    provider: "openai",
    model: model,
    prompt_tokens: promptTokens,
    completion_tokens: completionTokens,
    total_tokens: promptTokens + completionTokens,
    timestamp: new Date().toISOString()
  };

  if (eventId) {
    payload.event_id = eventId;
  }

  try {
    const response = await fetch("${baseUrl}/ingest", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": "YOUR_INGEST_KEY"
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.status === 201) {
      console.log("Usage logged successfully");
    } else if (response.status === 200 && data.duplicate) {
      console.log("Duplicate event ignored (idempotency)");
    } else {
      console.error(\`Error logging usage: \${response.status}\`, data);
    }
  } catch (error) {
    console.error("Failed to log usage:", error);
  }
}

// Example usage
await logOpenAIUsage(
  "${token}",
  "gpt-4o-mini-2024-07-18",
  100,
  50,
  "unique-event-123"  // Optional for idempotency
);`;
            }

            const nodejsOpenai = document.getElementById('nodejs-openai');
            if (nodejsOpenai) {
                nodejsOpenai.textContent = `import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: 'your-openai-api-key'
});

const COST_GUARDIAN_URL = "${baseUrl}/ingest";
const INGEST_KEY = "YOUR_INGEST_KEY";
const TRACKING_TOKEN = "${token}";

async function chatWithLogging(messages, model = "gpt-4o-mini-2024-07-18") {
  try {
    // Make OpenAI request
    const response = await openai.chat.completions.create({
      model: model,
      messages: messages
    });

    // Extract usage information
    const usage = response.usage;

    // Log to Cost Guardian
    const logPayload = {
      tracking_token: TRACKING_TOKEN,
      model: model,
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      cost_usd: calculateCost(usage, model),
      timestamp: new Date().toISOString(),
      event_id: response.id  // Use OpenAI response ID for idempotency
    };

    await fetch(COST_GUARDIAN_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": INGEST_KEY
      },
      body: JSON.stringify(logPayload)
    });

    return response;
  } catch (error) {
    console.error("Error in chat with logging:", error);
    throw error;
  }
}

function calculateCost(usage, model) {
  // Example pricing for gpt-4o-mini-2024-07-18
  const promptCostPer1k = 0.000150;
  const completionCostPer1k = 0.000600;
  
  const promptCost = (usage.prompt_tokens / 1000) * promptCostPer1k;
  const completionCost = (usage.completion_tokens / 1000) * completionCostPer1k;
  
  return promptCost + completionCost;
}

// Example usage
const messages = [
  { role: "user", content: "Hello, how are you?" }
];

const response = await chatWithLogging(messages);
console.log(response.choices[0].message.content);`;
            }
        }

        function copyCodeBlock(button) {
            const codeBlock = button.parentElement;
            const preElement = codeBlock.querySelector('pre');
            const text = preElement.textContent;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.textContent;
                    button.textContent = 'Copied!';
                    button.style.background = '#28a745';
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#007cba';
                    }, 2000);
                }).catch(() => {
                    fallbackCopyCodeBlock(text, button);
                });
            } else {
                fallbackCopyCodeBlock(text, button);
            }
        }

        function fallbackCopyCodeBlock(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = '#28a745';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#007cba';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy code block:', err);
            }
            
            document.body.removeChild(textArea);
        }

        // Close modal on click outside or Escape key
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('snippets-modal');
            if (e.target === modal) {
                closeSnippetsModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('snippets-modal');
            const isModalVisible = !modal.classList.contains('hidden');
            
            if (e.key === 'Escape' && isModalVisible) {
                closeSnippetsModal();
            }
        });

        // Filtering functions
        // Token filter management with graceful degradation
        async function fetchTrackingTokensWithCache() {
            if (tokenCache) {
                return tokenCache;
            }

            try {
                const response = await apiFetch('/ingest/tokens');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                tokenCache = data.tokens || [];
                return tokenCache;
            } catch (error) {
                // Graceful degradation - hide token filter on auth failure
                if (error.message.includes('401') || error.message.includes('403') || error.message.includes('404')) {
                    console.log('Token filter unavailable (auth required)');
                    document.getElementById('token-filter-group').style.display = 'none';
                    // Clear any stale token filter from localStorage
                    localStorage.removeItem('cg_token_filter');
                    return [];
                }
                throw error;
            }
        }

        function populateTokenOptions(tokens) {
            const select = document.getElementById('token-select');
            const current = select.value || '';
            
            // Clear existing options except "All Tokens"
            select.innerHTML = '<option value="">All Tokens</option>';
            
            if (tokens && tokens.length > 0) {
                tokens.forEach(token => {
                    const option = document.createElement('option');
                    option.value = token.id;
                    option.textContent = `${token.label} (${token.usage_count || 0} uses)`;
                    select.appendChild(option);
                });
                
                // Show the token filter group
                document.getElementById('token-filter-group').style.display = 'flex';
                
                // Restore previous selection if still valid
                const savedToken = localStorage.getItem('cg_token_filter');
                if (savedToken && [...select.options].some(o => o.value === savedToken)) {
                    select.value = savedToken;
                } else if (current && [...select.options].some(o => o.value === current)) {
                    select.value = current;
                }
            }
        }

        function getCurrentFilters() {
            const preset = document.getElementById('range-select').value;
            const model = document.getElementById('model-select').value;
            const tokenId = document.getElementById('token-select').value;

            let filters = { model };
            
            // Add token filter if selected
            if (tokenId) {
                filters.ingest_token_id = parseInt(tokenId);
            }

            if (preset === 'custom') {
                const sd = document.getElementById('start-date').value;
                const ed = document.getElementById('end-date').value;
                if (sd && ed) {
                    filters.start = toISOStartOfDay(sd);
                    filters.end = toISOEndOfDay(ed);
                }
                return filters; // no date filtering until both provided
            } else {
                const { start, end } = computePresetRange(preset);
                filters.start = start;
                filters.end = end;
                return filters;
            }
        }

        function onPresetChange() {
            const preset = document.getElementById('range-select').value;
            const customWrap = document.getElementById('custom-date-wrap');
            customWrap.style.display = preset === 'custom' ? 'flex' : 'none';
            if (preset !== 'custom') {
                // Save filter preference
                localStorage.setItem('cg_date_preset', preset);
                updateURLFromFilters();
                fetchData(getCurrentFilters());
            }
        }

        // Debounced model change handler
        let modelChangeTimeout;
        function onModelChange() {
            clearTimeout(modelChangeTimeout);
            modelChangeTimeout = setTimeout(() => {
                localStorage.setItem('cg_model_filter', document.getElementById('model-select').value);
                updateURLFromFilters();
                fetchData(getCurrentFilters());
            }, 150);
        }

        // Debounced token change handler
        let tokenChangeTimeout;
        function onTokenChange() {
            clearTimeout(tokenChangeTimeout);
            tokenChangeTimeout = setTimeout(() => {
                const tokenId = document.getElementById('token-select').value;
                localStorage.setItem('cg_token_filter', tokenId);
                updateURLFromFilters();
                fetchData(getCurrentFilters());
            }, 150);
        }

        function onDateChange() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            if (startDate && endDate) {
                updateURLFromFilters();
                fetchData(getCurrentFilters());
            } else if (startDate || endDate) {
                // Show hint when only one date is selected
                const message = startDate ? 'Please select an end date' : 'Please select a start date';
                renderTableMessage(message);
            }
        }

        // Load models from server for stable dropdown with fallback
        async function loadModels() {
            try {
                const response = await apiFetch('/models');
                if (response.ok) {
                    const data = await response.json();
                    const select = document.getElementById('model-select');
                    const currentValue = select.value;
                    
                    const opts = ['<option value="all">All Models</option>'].concat(
                        data.models.map(m => `<option value="${m}">${m}</option>`)
                    );
                    select.innerHTML = opts.join('');
                    
                    // Restore saved model filter
                    const savedModel = localStorage.getItem('cg_model_filter');
                    if (savedModel && [...select.options].some(o => o.value === savedModel)) {
                        select.value = savedModel;
                    } else if (currentValue && [...select.options].some(o => o.value === currentValue)) {
                        select.value = currentValue;
                    }
                }
            } catch (error) {
                console.error('Failed to load models:', error);
                // Fallback: populate from current data if available
                if (currentRows && currentRows.length > 0) {
                    populateModelOptions(currentRows);
                }
            }
        }

        // Set up event listeners
        document.getElementById('add-token-form').addEventListener('submit', addTrackingToken);

        // Filter event listeners
        document.getElementById('range-select').addEventListener('change', onPresetChange);
        document.getElementById('model-select').addEventListener('change', onModelChange);
        document.getElementById('token-select').addEventListener('change', onTokenChange);
        document.getElementById('apply-filters').addEventListener('click', () => fetchData(getCurrentFilters()));
        document.getElementById('start-date').addEventListener('change', onDateChange);
        document.getElementById('end-date').addEventListener('change', onDateChange);
        
        // CSV export listener
        document.getElementById('export-csv-btn').addEventListener('click', exportCSV);

        // URL state management for filter sharing
        function updateURLFromFilters() {
            const filters = getCurrentFilters();
            const params = new URLSearchParams(window.location.search);
            
            // Clear existing filter params
            params.delete('preset');
            params.delete('model');
            params.delete('token');
            params.delete('start');
            params.delete('end');
            
            // Add current filter values
            const preset = document.getElementById('range-select').value;
            if (preset !== 'this_month') params.set('preset', preset);
            if (filters.model && filters.model !== 'all') params.set('model', filters.model);
            if (filters.ingest_token_id) params.set('token', filters.ingest_token_id.toString());
            
            if (preset === 'custom') {
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;
                if (startDate) params.set('start', startDate);
                if (endDate) params.set('end', endDate);
            }
            
            // Update URL without triggering reload
            const newURL = params.toString() ? 
                `${window.location.pathname}?${params.toString()}` : 
                window.location.pathname;
            window.history.replaceState({}, '', newURL);
        }

        function loadFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Load preset
            const preset = params.get('preset') || localStorage.getItem('cg_date_preset') || 'this_month';
            document.getElementById('range-select').value = preset;
            
            // Load model
            const model = params.get('model') || localStorage.getItem('cg_model_filter') || 'all';
            document.getElementById('model-select').value = model;
            
            // Load token (URL takes precedence over localStorage)
            const token = params.get('token') || localStorage.getItem('cg_token_filter') || '';
            document.getElementById('token-select').value = token;
            
            // Load custom dates if preset is custom
            if (preset === 'custom') {
                const start = params.get('start');
                const end = params.get('end');
                if (start) document.getElementById('start-date').value = start;
                if (end) document.getElementById('end-date').value = end;
            }
        }

        // Initialize on page load
        async function initialize() {
            // Check if production requires immediate sign-in
            const requireSignIn = document.body.dataset.requireSignin === 'true';
            const existingKey = getApiKey();
            
            if (requireSignIn && !existingKey) {
                // Production mode with no key - show auth modal immediately
                showLogin();
                authInProgress = true; // Prevent escape/cancel until signed in
                return; // Don't try to load data until signed in
            }
            
            // Load filters from URL first, then localStorage
            loadFiltersFromURL();
            
            // Show/hide custom date inputs based on preset
            const preset = document.getElementById('range-select').value;
            const customWrap = document.getElementById('custom-date-wrap');
            customWrap.style.display = preset === 'custom' ? 'flex' : 'none';
            
            if (existingKey) {
                // Try to authenticate with existing key
                updateAuthStatus(existingKey);
                try {
                    // Load tokens first to populate dropdown, then other data
                    const tokens = await fetchTrackingTokensWithCache();
                    populateTokenOptions(tokens);
                    
                    // Load data, keys, and models in parallel
                    await Promise.all([
                        fetchData(getCurrentFilters()),
                        loadModels()
                    ]);
                } catch (error) {
                    // Existing key invalid, clear it
                    clearApiKey();
                    updateAuthStatus('');
                    showLogin('Your session has expired. Please sign in again.');
                }
            } else {
                // No key - try fetching data to see if auth is required (dev mode)
                try {
                    // Try loading tokens (may fail silently if auth required)
                    const tokens = await fetchTrackingTokensWithCache();
                    populateTokenOptions(tokens);
                    
                    await Promise.all([
                        fetchData(getCurrentFilters()),
                        loadModels()
                    ]);
                } catch (error) {
                    if (error.message.includes('Unauthorized')) {
                        showLogin();
                    }
                }
            }
        }

        // Start the app
        initialize();
    </script>
</body>
</html>