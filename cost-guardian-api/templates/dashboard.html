<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <title>Cost Guardian Dashboard</title>
    <style>
        /* Auth modal styles */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .auth-modal {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 400px;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .auth-modal h2 {
            margin-top: 0;
            color: #333;
        }
        .auth-modal input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .auth-modal input[type="password"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 3px rgba(0, 124, 186, 0.1);
        }
        .auth-modal label {
            display: block;
            margin: 1rem 0 0.5rem;
            color: #555;
        }
        .auth-modal .checkbox-row {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        .auth-modal .checkbox-row input {
            margin-right: 0.5rem;
        }
        .auth-modal .buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        .auth-modal button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }
        .auth-modal .btn-primary {
            background: #007cba;
            color: white;
        }
        .auth-modal .btn-primary:hover {
            background: #005a87;
        }
        .auth-modal .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .auth-modal .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }
        .auth-modal .btn-secondary:hover {
            background: #e0e0e0;
        }
        .auth-error {
            color: #d32f2f;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        .hidden {
            display: none !important;
        }
        /* Auth status footer */
        /* Tracking Tokens section styles */
        .tracking-tokens-section {
            background: #f0f8ff;
            border: 1px solid #007cba;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .tracking-tokens-section h2 {
            margin-top: 0;
            color: #005a87;
            font-size: 1.2rem;
        }
        .section-description {
            color: #666;
            font-size: 0.9rem;
            margin: 0.5rem 0 1rem 0;
            font-style: italic;
        }
        .add-token-form {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .add-token-form input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 0.5rem;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .add-token-form input[type="text"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 3px rgba(0, 124, 186, 0.1);
        }
        .tokens-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .token-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .token-info {
            flex: 1;
            min-width: 200px;
        }
        .token-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 0.25rem;
        }
        .token-value {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            color: #666;
            word-break: break-all;
        }
        .token-meta {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.25rem;
        }
        .token-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .token-status {
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        .token-status.active {
            background: #d4edda;
            color: #155724;
        }
        .token-status.inactive {
            background: #f8d7da;
            color: #721c24;
        }
        .tokens-message {
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        .tokens-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .tokens-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .no-tokens {
            color: #666;
            font-style: italic;
            padding: 1rem;
            text-align: center;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .btn-primary, .btn-secondary, .btn-danger {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .btn-primary {
            background: #007cba;
            color: white;
        }
        .btn-primary:hover {
            background: #005a87;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }

        /* API Keys section styles */
        .keys-section {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .keys-section h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.2rem;
        }
        .add-key-form {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .add-key-form input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .add-key-form input[name="label"] {
            flex: 1;
            min-width: 150px;
        }
        .add-key-form input[name="key"] {
            flex: 2;
            min-width: 200px;
        }
        .add-key-form button {
            padding: 0.5rem 1rem;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .add-key-form button:hover {
            background: #005a87;
        }
        .add-key-form button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .keys-list {
            margin: 1rem 0;
        }
        .key-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            background: white;
        }
        .key-info {
            flex: 1;
            margin-right: 1rem;
        }
        .key-label {
            font-weight: bold;
            color: #333;
        }
        .key-details {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.25rem;
        }
        .key-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #007cba;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .delete-btn, .probe-btn {
            padding: 0.25rem 0.5rem;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .delete-btn {
            background: #dc3545;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        .probe-btn {
            background: #28a745;
        }
        .probe-btn:hover {
            background: #218838;
        }
        .probe-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .keys-message {
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .keys-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .keys-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .keys-message.hidden {
            display: none;
        }
        
        .auth-status {
            margin-top: 2rem;
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #666;
        }
        .auth-status .key-display {
            font-family: monospace;
            color: #333;
        }
        .auth-status .sign-out {
            color: #007cba;
            cursor: pointer;
            text-decoration: underline;
        }
        .auth-status .sign-out:hover {
            color: #005a87;
        }
        /* Loading and disabled states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .status-message {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 4px;
            font-weight: bold;
        }
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
        }
        .status-error {
            background: #ffebee;
            color: #d32f2f;
        }

        /* Usage snippets modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }
        .modal-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.3rem;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .modal-close:hover {
            background: #e0e0e0;
        }
        .modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }
        .tab-button {
            flex: 1;
            padding: 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            color: #666;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .tab-button:hover {
            background: #e9ecef;
        }
        .tab-button.active {
            color: #007cba;
            border-bottom-color: #007cba;
            background: white;
        }
        .tab-content {
            display: none;
            padding: 1.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .snippet-description {
            margin-bottom: 1rem;
            color: #666;
            line-height: 1.4;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            margin: 1rem 0;
            position: relative;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .copy-code-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.8;
        }
        .copy-code-btn:hover {
            opacity: 1;
            background: #005a87;
        }
        .snippet-notes {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 0.9rem;
        }
        .snippet-notes strong {
            color: #1976d2;
        }
        .snippet-section {
            margin-bottom: 2rem;
        }
        .snippet-section h4 {
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        /* Data filters styles */
        .filters {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }
        .filters .group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .filters label {
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        .filters select, .filters input[type="date"] {
            padding: 0.4rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .filters select:focus, .filters input[type="date"]:focus {
            outline: none;
            border-color: #007cba;
            box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.1);
        }
        #custom-date-wrap {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .spinner-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ccc;
            border-top: 2px solid #007cba;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Auth Modal -->
    <div id="auth-overlay" class="auth-overlay hidden">
        <div class="auth-modal">
            <h2>🔑 API Authentication</h2>
            <form id="auth-form">
                <label for="api-key-input">API Key</label>
                <input 
                    type="password" 
                    id="api-key-input" 
                    placeholder="Enter your API key..."
                    required
                    autocomplete="off"
                    autocapitalize="off"
                    spellcheck="false"
                >
                <div class="checkbox-row">
                    <input type="checkbox" id="remember-key">
                    <label for="remember-key">Remember on this device</label>
                </div>
                <div id="auth-error" class="auth-error hidden"></div>
                <div class="buttons">
                    <button type="button" id="cancel-btn" class="btn-secondary">Cancel</button>
                    <button type="submit" id="signin-btn" class="btn-primary">Sign In</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Usage Snippets Modal -->
    <div id="snippets-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h3>📝 Usage Examples</h3>
                <button class="modal-close" onclick="closeSnippetsModal()">&times;</button>
            </div>
            <div class="modal-content">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('curl')">cURL</button>
                    <button class="tab-button" onclick="switchTab('python')">Python</button>
                    <button class="tab-button" onclick="switchTab('nodejs')">Node.js</button>
                </div>
                
                <div id="curl-tab" class="tab-content active">
                    <div class="snippet-description">
                        Send usage data to Cost Guardian using cURL from your command line or shell scripts.
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Basic Usage</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="curl-basic">curl -X POST "${window.location.origin}/ingest" \
  -H "Content-Type: application/json" \
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \
  -d '{
    "tracking_token": "TRACKING_TOKEN",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "cost_usd": 0.002250
  }'</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>With Event ID (Idempotency)</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="curl-idempotent">curl -X POST "${window.location.origin}/ingest" \
  -H "Content-Type: application/json" \
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \
  -d '{
    "tracking_token": "TRACKING_TOKEN",
    "event_id": "unique-event-123",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150,
    "cost_usd": 0.002250,
    "timestamp": "2024-01-15T10:30:00Z"
  }'</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Note:</strong> Replace <code>YOUR_INGEST_KEY</code> with your server's ingest key and <code>TRACKING_TOKEN</code> with the token for this project.
                    </div>
                </div>

                <div id="python-tab" class="tab-content">
                    <div class="snippet-description">
                        Integrate Cost Guardian into your Python applications using the requests library.
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Basic Integration</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="python-basic">import requests
import json
from datetime import datetime, timezone

def log_openai_usage(tracking_token, model, prompt_tokens, completion_tokens, cost_usd, event_id=None):
    """Log OpenAI usage to Cost Guardian"""
    
    payload = {
        "tracking_token": tracking_token,
        "model": model,
        "prompt_tokens": prompt_tokens,
        "completion_tokens": completion_tokens,
        "cost_usd": cost_usd,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    if event_id:
        payload["event_id"] = event_id
    
    response = requests.post(
        "${window.location.origin}/ingest",
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": "YOUR_INGEST_KEY"
        },
        json=payload
    )
    
    if response.status_code == 201:
        print("Usage logged successfully")
    elif response.status_code == 200:
        result = response.json()
        if result.get("duplicate"):
            print("Duplicate event ignored (idempotency)")
    else:
        print(f"Error logging usage: {response.status_code} - {response.text}")

# Example usage
log_openai_usage(
    tracking_token="TRACKING_TOKEN",
    model="gpt-4o-mini-2024-07-18",
    prompt_tokens=100,
    completion_tokens=50,
    cost_usd=0.002250,
    event_id="unique-event-123"  # Optional for idempotency
)</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>OpenAI Integration Example</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="python-openai">import openai
import requests
from datetime import datetime, timezone

# Configure OpenAI and Cost Guardian
openai.api_key = "your-openai-api-key"
COST_GUARDIAN_URL = "${window.location.origin}/ingest"
INGEST_KEY = "YOUR_INGEST_KEY"
TRACKING_TOKEN = "TRACKING_TOKEN"

def chat_with_logging(messages, model="gpt-4o-mini-2024-07-18"):
    """Make OpenAI chat completion and log usage to Cost Guardian"""
    
    # Make OpenAI request
    response = openai.chat.completions.create(
        model=model,
        messages=messages
    )
    
    # Extract usage information
    usage = response.usage
    
    # Log to Cost Guardian
    log_payload = {
        "tracking_token": TRACKING_TOKEN,
        "model": model,
        "prompt_tokens": usage.prompt_tokens,
        "completion_tokens": usage.completion_tokens,
        "total_tokens": usage.total_tokens,
        "cost_usd": calculate_cost(usage, model),  # Implement your cost calculation
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "event_id": response.id  # Use OpenAI response ID for idempotency
    }
    
    requests.post(
        COST_GUARDIAN_URL,
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": INGEST_KEY
        },
        json=log_payload
    )
    
    return response

def calculate_cost(usage, model):
    """Calculate cost based on OpenAI pricing"""
    # Example pricing for gpt-4o-mini-2024-07-18
    prompt_cost_per_1k = 0.000150
    completion_cost_per_1k = 0.000600
    
    prompt_cost = (usage.prompt_tokens / 1000) * prompt_cost_per_1k
    completion_cost = (usage.completion_tokens / 1000) * completion_cost_per_1k
    
    return prompt_cost + completion_cost</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Requirements:</strong> <code>pip install requests openai</code><br>
                        <strong>Note:</strong> Update the cost calculation function with current OpenAI pricing for your models.
                    </div>
                </div>

                <div id="nodejs-tab" class="tab-content">
                    <div class="snippet-description">
                        Integrate Cost Guardian into your Node.js applications using fetch or axios.
                    </div>
                    
                    <div class="snippet-section">
                        <h4>Basic Integration (Node.js 18+)</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="nodejs-basic">async function logOpenAIUsage(trackingToken, model, promptTokens, completionTokens, costUsd, eventId = null) {
  const payload = {
    tracking_token: trackingToken,
    model: model,
    prompt_tokens: promptTokens,
    completion_tokens: completionTokens,
    cost_usd: costUsd,
    timestamp: new Date().toISOString()
  };

  if (eventId) {
    payload.event_id = eventId;
  }

  try {
    const response = await fetch("${window.location.origin}/ingest", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": "YOUR_INGEST_KEY"
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.status === 201) {
      console.log("Usage logged successfully");
    } else if (response.status === 200 && data.duplicate) {
      console.log("Duplicate event ignored (idempotency)");
    } else {
      console.error(`Error logging usage: ${response.status}`, data);
    }
  } catch (error) {
    console.error("Failed to log usage:", error);
  }
}

// Example usage
await logOpenAIUsage(
  "TRACKING_TOKEN",
  "gpt-4o-mini-2024-07-18",
  100,
  50,
  0.002250,
  "unique-event-123"  // Optional for idempotency
);</pre>
                        </div>
                    </div>

                    <div class="snippet-section">
                        <h4>OpenAI Integration Example</h4>
                        <div class="code-block">
                            <button class="copy-code-btn" onclick="copyCodeBlock(this)">Copy</button>
                            <pre id="nodejs-openai">import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: 'your-openai-api-key'
});

const COST_GUARDIAN_URL = "${window.location.origin}/ingest";
const INGEST_KEY = "YOUR_INGEST_KEY";
const TRACKING_TOKEN = "TRACKING_TOKEN";

async function chatWithLogging(messages, model = "gpt-4o-mini-2024-07-18") {
  try {
    // Make OpenAI request
    const response = await openai.chat.completions.create({
      model: model,
      messages: messages
    });

    // Extract usage information
    const usage = response.usage;

    // Log to Cost Guardian
    const logPayload = {
      tracking_token: TRACKING_TOKEN,
      model: model,
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      cost_usd: calculateCost(usage, model),
      timestamp: new Date().toISOString(),
      event_id: response.id  // Use OpenAI response ID for idempotency
    };

    await fetch(COST_GUARDIAN_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": INGEST_KEY
      },
      body: JSON.stringify(logPayload)
    });

    return response;
  } catch (error) {
    console.error("Error in chat with logging:", error);
    throw error;
  }
}

function calculateCost(usage, model) {
  // Example pricing for gpt-4o-mini-2024-07-18
  const promptCostPer1k = 0.000150;
  const completionCostPer1k = 0.000600;
  
  const promptCost = (usage.prompt_tokens / 1000) * promptCostPer1k;
  const completionCost = (usage.completion_tokens / 1000) * completionCostPer1k;
  
  return promptCost + completionCost;
}

// Example usage
const messages = [
  { role: "user", content: "Hello, how are you?" }
];

const response = await chatWithLogging(messages);
console.log(response.choices[0].message.content);</pre>
                        </div>
                    </div>

                    <div class="snippet-notes">
                        <strong>Requirements:</strong> <code>npm install openai</code><br>
                        <strong>Note:</strong> For Node.js versions before 18, use <code>node-fetch</code> or <code>axios</code> instead of native fetch.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <h1>Cost Guardian Token Usage</h1>
    
    <!-- Loading/Status messages -->
    <div id="status-message" class="hidden"></div>
    
    <!-- Tracking Tokens Management Section -->
    <div class="tracking-tokens-section">
        <h2>🏷️ Tracking Tokens</h2>
        <p class="section-description">Manage tracking tokens for client-push ingestion. Each token allows client applications to send usage data to the /ingest endpoint.</p>
        <div id="tokens-message" class="tokens-message hidden"></div>
        
        <form class="add-token-form" id="add-token-form">
            <input type="text" name="label" placeholder="Token label (e.g., 'Production App')" required maxlength="64">
            <button type="submit">Create Token</button>
        </form>
        
        <div class="tokens-list" id="tokens-list">
            <!-- Tokens will be populated here -->
        </div>
    </div>

    <!-- API Keys Management Section -->
    <div class="keys-section">
        <h2>API Keys</h2>
        <div id="keys-message" class="keys-message hidden"></div>
        
        <form class="add-key-form" id="add-key-form">
            <input type="text" name="label" placeholder="Key label (e.g., 'Production')" required maxlength="64">
            <input type="password" name="key" placeholder="OpenAI API key (sk-...)" required maxlength="256">
            <input type="hidden" name="provider" value="openai">
            <button type="submit">Add Key</button>
        </form>
        
        <div class="keys-list" id="keys-list">
            <!-- Keys will be populated here -->
        </div>
    </div>
    
    <button id="reset-btn" disabled>Reset Data</button>
    <p id="reset-status"></p>
    
    <!-- Data Filters -->
    <div class="filters" aria-live="polite">
        <div class="group">
            <label for="range-select">Date Range:</label>
            <select id="range-select">
                <option value="today">Today</option>
                <option value="this_week">This Week</option>
                <option value="this_month" selected>This Month</option>
                <option value="custom">Custom</option>
            </select>
            <span id="custom-date-wrap" style="display:none;">
                <input type="date" id="start-date" aria-label="Start date">
                <input type="date" id="end-date" aria-label="End date">
                <button type="button" id="apply-filters" class="btn-primary">Apply</button>
            </span>
        </div>
        <div class="group">
            <label for="model-select">Model:</label>
            <select id="model-select">
                <option value="all" selected>All Models</option>
            </select>
        </div>
        <div class="spinner-container" id="filter-spinner" style="display:none;">
            <span class="spinner" role="status" aria-label="Loading"></span>
            <span class="sr-only">Loading data...</span>
        </div>
    </div>
    
    <table border="1" id="usage-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Timestamp</th>
                <th>Model</th>
                <th>Prompt Tokens</th>
                <th>Completion Tokens</th>
                <th>Total Tokens</th>
                <th>Estimated Cost (USD)</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        <tfoot id="usage-totals">
            <tr>
                <td><strong>Totals</strong></td>
                <td></td>
                <td></td>
                <td id="sum-prompt"><strong>0</strong></td>
                <td id="sum-completion"><strong>0</strong></td>
                <td id="sum-total"><strong>0</strong></td>
                <td id="sum-cost"><strong>$0.0000</strong></td>
            </tr>
        </tfoot>
    </table>

    <!-- Auth Status Footer -->
    <div id="auth-status" class="auth-status hidden">
        <span>🔓 Signed in as: <span id="key-display" class="key-display"></span></span>
        <span class="sign-out" id="sign-out-btn">Sign out</span>
    </div>

    <script>
        // Global state
        let authInProgress = false;
        let abortController = null;
        const API_KEY_STORAGE = 'cg_api_key';

        // Storage helpers
        function getApiKey() {
            // Prefer sessionStorage over localStorage
            return sessionStorage.getItem(API_KEY_STORAGE) || 
                   localStorage.getItem(API_KEY_STORAGE) || '';
        }

        function setApiKey(key, remember = false) {
            if (remember) {
                localStorage.setItem(API_KEY_STORAGE, key);
                sessionStorage.removeItem(API_KEY_STORAGE);
            } else {
                sessionStorage.setItem(API_KEY_STORAGE, key);
                localStorage.removeItem(API_KEY_STORAGE);
            }
        }

        function clearApiKey() {
            sessionStorage.removeItem(API_KEY_STORAGE);
            localStorage.removeItem(API_KEY_STORAGE);
        }

        // UI helpers
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }

        function hideStatus() {
            const statusEl = document.getElementById('status-message');
            statusEl.className = 'status-message hidden';
        }

        function updateAuthStatus(key) {
            const statusEl = document.getElementById('auth-status');
            const keyDisplayEl = document.getElementById('key-display');
            
            if (key) {
                // Show masked key (last 4 chars)
                const masked = '•'.repeat(Math.max(0, key.length - 4)) + key.slice(-4);
                keyDisplayEl.textContent = masked;
                statusEl.classList.remove('hidden');
            } else {
                statusEl.classList.add('hidden');
            }
        }

        function showLogin(errorMessage = '') {
            if (authInProgress) return;
            
            const overlay = document.getElementById('auth-overlay');
            const errorEl = document.getElementById('auth-error');
            const inputEl = document.getElementById('api-key-input');
            
            if (errorMessage) {
                errorEl.textContent = errorMessage;
                errorEl.classList.remove('hidden');
            } else {
                errorEl.classList.add('hidden');
            }
            
            overlay.classList.remove('hidden');
            setTimeout(() => inputEl.focus(), 100);
        }

        function hideLogin() {
            const overlay = document.getElementById('auth-overlay');
            const errorEl = document.getElementById('auth-error');
            overlay.classList.add('hidden');
            errorEl.classList.add('hidden');
        }

        // Enhanced fetch wrapper
        async function apiFetch(path, opts = {}) {
            const headers = new Headers(opts.headers || {});
            const key = getApiKey();
            
            if (key) {
                headers.set('X-API-Key', key);
            }

            // Create & expose controller so Sign out can cancel
            const controller = opts.signal ? null : new AbortController();
            const signal = opts.signal || controller.signal;
            if (controller) abortController = controller;

            try {
                const response = await fetch(path, { 
                    ...opts, 
                    headers, 
                    signal 
                });

                // Handle 401 Unauthorized
                if (response.status === 401) {
                    if (!authInProgress) {
                        clearApiKey();
                        updateAuthStatus('');
                        showLogin('Unauthorized. Please enter your API key.');
                        authInProgress = true;
                    }
                    throw new Error('Unauthorized');
                }

                // Handle 429 Rate Limited
                if (response.status === 429) {
                    showStatus('Rate limited. Retrying in 2 seconds...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Retry once
                    const retryResponse = await fetch(path, { 
                        ...opts, 
                        headers, 
                        signal 
                    });
                    
                    if (retryResponse.status === 429) {
                        showStatus('Rate limit exceeded. Please try again later.', 'error');
                        throw new Error('Rate limited');
                    }
                    
                    hideStatus();
                    return retryResponse;
                }

                hideStatus();
                return response;
            } catch (error) {
                if (error.name !== 'AbortError' && error.message !== 'Unauthorized' && error.message !== 'Rate limited') {
                    showStatus(`Network error: ${error.message}`, 'error');
                }
                throw error;
            } finally {
                // Clear reference so we don't accidentally abort later requests
                if (controller && abortController === controller) abortController = null;
            }
        }

        // Table rendering with totals
        function renderRows(rows) {
            const tableBody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            if (Array.isArray(rows)) {
                rows.forEach(row => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${row.id ?? ''}</td>
                        <td>${row.timestamp ?? ''}</td>
                        <td>${row.model ?? ''}</td>
                        <td>${row.promptTokens ?? ''}</td>
                        <td>${row.completionTokens ?? ''}</td>
                        <td>${row.totalTokens ?? ''}</td>
                        <td>${row.estimatedCostUSD ?? ''}</td>
                    `;
                    tableBody.appendChild(tr);
                });
            }
            
            // Update totals row
            renderTotals(computeTotals(rows));
        }

        function computeTotals(rows) {
            if (!Array.isArray(rows) || rows.length === 0) {
                return {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0,
                    estimatedCostUSD: 0
                };
            }
            
            return rows.reduce((totals, row) => {
                totals.promptTokens += parseFloat(row.promptTokens) || 0;
                totals.completionTokens += parseFloat(row.completionTokens) || 0;
                totals.totalTokens += parseFloat(row.totalTokens) || 0;
                totals.estimatedCostUSD += parseFloat(row.estimatedCostUSD) || 0;
                return totals;
            }, {
                promptTokens: 0,
                completionTokens: 0,
                totalTokens: 0,
                estimatedCostUSD: 0
            });
        }

        function renderTotals(totals) {
            const formatter = new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: 'USD', 
                minimumFractionDigits: 4 
            });
            
            document.getElementById('sum-prompt').innerHTML = `<strong>${totals.promptTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-completion').innerHTML = `<strong>${totals.completionTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-total').innerHTML = `<strong>${totals.totalTokens.toLocaleString()}</strong>`;
            document.getElementById('sum-cost').innerHTML = `<strong>${formatter.format(totals.estimatedCostUSD)}</strong>`;
        }

        // Date and filtering helpers
        function toISOStartOfDay(dateStr) {
            return new Date(dateStr + 'T00:00:00Z').toISOString();
        }

        function toISOEndOfDay(dateStr) {
            return new Date(dateStr + 'T23:59:59Z').toISOString();
        }

        function computePresetRange(preset) {
            const now = new Date();
            const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            
            if (preset === 'today') {
                return { 
                    start: today.toISOString(), 
                    end: new Date(today.getTime() + 86399 * 1000).toISOString() 
                };
            }
            
            if (preset === 'this_week') {
                // ISO week: Monday start. Compute day (0=Sun..6=Sat); shift to Monday.
                const day = (today.getUTCDay() + 6) % 7;
                const monday = new Date(today.getTime() - day * 86400000);
                const sundayEnd = new Date(monday.getTime() + 6 * 86400000 + 86399 * 1000);
                return { start: monday.toISOString(), end: sundayEnd.toISOString() };
            }
            
            if (preset === 'this_month') {
                const first = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));
                const last = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() + 1, 0, 23, 59, 59));
                return { start: first.toISOString(), end: last.toISOString() };
            }
            
            return { start: null, end: null };
        }

        function renderTableMessage(text, type = 'info') {
            const tbody = document.getElementById('usage-table').getElementsByTagName('tbody')[0];
            const color = type === 'error' ? '#d32f2f' : '#666';
            tbody.innerHTML = `<tr><td colspan="7" style="color:${color}; padding:1rem; text-align:center;">${text}</td></tr>`;
        }

        function populateModelOptions(rows) {
            const select = document.getElementById('model-select');
            const current = select.value || 'all';
            const models = Array.from(new Set((rows || []).map(r => r.model).filter(Boolean))).sort();
            
            // Keep first option as "All Models"
            const opts = ['<option value="all">All Models</option>'].concat(
                models.map(m => `<option value="${m}">${m}</option>`)
            );
            select.innerHTML = opts.join('');
            
            // Try to preserve previous selection if still present
            if ([...select.options].some(o => o.value === current)) {
                select.value = current;
            }
        }

        // Enhanced data fetching with filters
        async function fetchData(filters = {}) {
            try {
                // Loading state
                document.getElementById('reset-btn').disabled = true;
                document.getElementById('status-message').classList.add('hidden');
                renderTableMessage('<span class="spinner" aria-hidden="true"></span> Loading…');

                const params = new URLSearchParams();
                if (filters.start) params.set('start', filters.start);
                if (filters.end) params.set('end', filters.end);
                if (filters.model && filters.model !== 'all') params.set('model', filters.model);

                const response = await apiFetch('/data' + (params.toString() ? `?${params}` : ''));
                
                // Check for server validation errors
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP ${response.status}`);
                }
                
                const payload = await response.json();
                const rows = Array.isArray(payload) ? payload : payload?.data;

                if (!rows || rows.length === 0) {
                    renderRows([]); // clears body
                    renderTableMessage('No data for the selected filters.');
                    renderTotals(computeTotals([])); // ensure totals row shows zeros
                    return;
                }

                renderRows(rows);
                populateModelOptions(rows);
                renderTotals(computeTotals(rows));
                document.getElementById('reset-btn').disabled = false;
                
            } catch (error) {
                console.error('Error loading data:', error);
                renderRows([]); // clears body
                
                // Display server error messages in the table
                const errorMessage = error.message.includes('HTTP') ? 
                    'Failed to load data. Please try again.' : 
                    `Error: ${error.message}`;
                    
                renderTableMessage(errorMessage, 'error');
                renderTotals(computeTotals([]));
            }
        }

        // Auth form handling
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const submitBtn = document.getElementById('signin-btn');
            const apiKeyInput = document.getElementById('api-key-input');
            const rememberCheckbox = document.getElementById('remember-key');
            const errorEl = document.getElementById('auth-error');
            
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                errorEl.textContent = 'API key is required';
                errorEl.classList.remove('hidden');
                return;
            }
            
            // Set loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Signing in...';
            errorEl.classList.add('hidden');
            
            try {
                // Store key temporarily for test
                setApiKey(apiKey, rememberCheckbox.checked);
                
                // Test the key by fetching data
                await fetchData();
                
                // Success - hide modal and update UI
                hideLogin();
                updateAuthStatus(apiKey);
                authInProgress = false;
                
            } catch (error) {
                // Auth failed - clear key and show error
                clearApiKey();
                if (error.message === 'Unauthorized') {
                    errorEl.textContent = 'Invalid API key. Please check and try again.';
                } else {
                    errorEl.textContent = 'Authentication failed. Please try again.';
                }
                errorEl.classList.remove('hidden');
            } finally {
                // Reset button state
                submitBtn.disabled = false;
                submitBtn.textContent = 'Sign In';
            }
        });

        // Cancel/close modal
        document.getElementById('cancel-btn').addEventListener('click', () => {
            // Only allow cancel if dashboard is public (no immediate auth required)
            hideLogin();
            authInProgress = false;
        });

        // Sign out
        document.getElementById('sign-out-btn').addEventListener('click', () => {
            // Abort any in-flight requests
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            
            clearApiKey();
            updateAuthStatus('');
            document.getElementById('reset-btn').disabled = true;
            
            // Clear table
            renderRows([]);
            
            showLogin();
        });

        // Reset button with auth
        document.getElementById('reset-btn').addEventListener('click', async () => {
            if (!getApiKey()) {
                showLogin('Please sign in to reset data.');
                return;
            }
            
            const resetBtn = document.getElementById('reset-btn');
            const resetStatus = document.getElementById('reset-status');
            
            resetBtn.disabled = true;
            resetBtn.textContent = 'Resetting...';
            resetStatus.textContent = '';
            
            try {
                const response = await apiFetch('/reset', { method: 'DELETE' });
                const data = await response.json();
                resetStatus.textContent = data.message || 'Reset complete.';
                
                // Reload table after successful reset
                await fetchData();
                
            } catch (error) {
                resetStatus.textContent = 'Reset failed.';
                console.error('Error resetting data:', error);
            } finally {
                resetBtn.disabled = false;
                resetBtn.textContent = 'Reset Data';
            }
        });

        // Keyboard accessibility
        document.addEventListener('keydown', (e) => {
            const overlay = document.getElementById('auth-overlay');
            const isModalVisible = !overlay.classList.contains('hidden');
            
            if (e.key === 'Escape' && isModalVisible) {
                // Only close on escape if we don't require immediate auth
                const hasKey = getApiKey();
                if (hasKey || !authInProgress) {
                    hideLogin();
                    authInProgress = false;
                }
            }
        });

        // API Key Management Functions
        function showKeysMessage(message, isError = false) {
            const messageEl = document.getElementById('keys-message');
            messageEl.textContent = message;
            messageEl.className = isError ? 'keys-message error' : 'keys-message success';
            messageEl.classList.remove('hidden');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                messageEl.classList.add('hidden');
            }, 5000);
        }

        async function fetchKeys() {
            try {
                const response = await apiFetch('/keys');
                const data = await response.json();
                renderKeys(data.keys || []);
            } catch (error) {
                console.error('Failed to fetch keys:', error);
                showKeysMessage('Failed to load API keys', true);
            }
        }

        function renderKeys(keys) {
            const listEl = document.getElementById('keys-list');
            
            if (!keys || keys.length === 0) {
                listEl.innerHTML = '<p style="color: #666; font-style: italic;">No API keys configured. Add one above to get started.</p>';
                return;
            }

            listEl.innerHTML = keys.map(key => `
                <div class="key-item" data-key-id="${key.id}">
                    <div class="key-info">
                        <div class="key-label">${escapeHtml(key.label)}</div>
                        <div class="key-details">
                            ${escapeHtml(key.mask)} • ${key.provider} • 
                            ${key.active ? 'Active' : 'Inactive'} • 
                            Created: ${new Date(key.created_at).toLocaleDateString()}
                            ${key.last_ok ? ` • Last OK: ${new Date(key.last_ok).toLocaleString()}` : ''}
                        </div>
                    </div>
                    <div class="key-actions">
                        <label class="toggle-switch">
                            <input type="checkbox" ${key.active ? 'checked' : ''} 
                                   onchange="toggleKeyActive(${key.id}, this.checked)">
                            <span class="slider"></span>
                        </label>
                        <button class="probe-btn" onclick="probeKey(${key.id}, '${escapeHtml(key.label)}')">
                            Test
                        </button>
                        <button class="delete-btn" onclick="deleteKey(${key.id}, '${escapeHtml(key.label)}')">
                            Delete
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function addKey(event) {
            event.preventDefault();
            
            const form = event.target;
            const formData = new FormData(form);
            const submitButton = form.querySelector('button[type="submit"]');
            
            const data = {
                label: formData.get('label').trim(),
                key: formData.get('key').trim(),
                provider: formData.get('provider')
            };

            // Basic validation
            if (!data.label || data.label.length > 64) {
                showKeysMessage('Label must be 1-64 characters', true);
                return;
            }
            
            if (!data.key || data.key.length > 256) {
                showKeysMessage('Key must be 1-256 characters', true);
                return;
            }

            if (!data.key.startsWith('sk-')) {
                showKeysMessage('OpenAI API keys should start with "sk-"', true);
                return;
            }

            submitButton.disabled = true;
            submitButton.textContent = 'Adding...';

            try {
                const response = await apiFetch('/keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showKeysMessage(`Added key "${data.label}" successfully`);
                    form.reset();
                    await fetchKeys(); // Refresh the list
                } else {
                    showKeysMessage(result.message || 'Failed to add key', true);
                }
            } catch (error) {
                console.error('Error adding key:', error);
                showKeysMessage('Failed to add key', true);
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Add Key';
            }
        }

        async function toggleKeyActive(keyId, active) {
            try {
                const response = await apiFetch(`/keys/${keyId}/active`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ active })
                });

                if (response.ok) {
                    await fetchKeys(); // Refresh the list
                    showKeysMessage(`Key ${active ? 'activated' : 'deactivated'}`);
                } else {
                    const result = await response.json();
                    showKeysMessage(result.message || 'Failed to update key', true);
                    await fetchKeys(); // Refresh to revert the toggle
                }
            } catch (error) {
                console.error('Error toggling key:', error);
                showKeysMessage('Failed to update key', true);
                await fetchKeys(); // Refresh to revert the toggle
            }
        }

        async function deleteKey(keyId, label) {
            if (!confirm(`Are you sure you want to delete the key "${label}"? This cannot be undone.`)) {
                return;
            }

            try {
                const response = await apiFetch(`/keys/${keyId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showKeysMessage(`Deleted key "${label}"`);
                    await fetchKeys(); // Refresh the list
                } else {
                    const result = await response.json();
                    showKeysMessage(result.message || 'Failed to delete key', true);
                }
            } catch (error) {
                console.error('Error deleting key:', error);
                showKeysMessage('Failed to delete key', true);
            }
        }

        async function probeKey(keyId, label) {
            const button = document.querySelector(`[data-key-id="${keyId}"] .probe-btn`);
            const originalText = button.textContent;
            
            button.disabled = true;
            button.textContent = 'Testing...';

            try {
                const response = await apiFetch(`/keys/${keyId}/probe`, {
                    method: 'POST'
                });

                const result = await response.json();
                
                if (response.ok && result.success) {
                    showKeysMessage(`✓ ${result.message}`);
                    await fetchKeys(); // Refresh to show updated last_ok timestamp
                } else {
                    showKeysMessage(`✗ ${result.message}`, true);
                }
            } catch (error) {
                console.error('Error probing key:', error);
                showKeysMessage(`Failed to test key "${label}"`, true);
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        // Tracking Tokens functionality
        async function fetchTrackingTokens() {
            try {
                const response = await apiFetch('/ingest/tokens');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                displayTrackingTokens(data.tokens);
            } catch (error) {
                console.error('Error fetching tracking tokens:', error);
                showTokensMessage('Failed to load tracking tokens', 'error');
            }
        }

        function displayTrackingTokens(tokens) {
            const listEl = document.getElementById('tokens-list');
            
            if (!tokens || tokens.length === 0) {
                listEl.innerHTML = '<p class="no-tokens">No tracking tokens found. Create one to start using client-push ingestion.</p>';
                return;
            }

            listEl.innerHTML = tokens.map(token => {
                const createdDate = new Date(token.created_at).toLocaleDateString();
                const lastSeenDate = token.last_seen_at ? new Date(token.last_seen_at).toLocaleString() : 'Never';
                const usageCount = token.usage_count || 0;
                
                return `
                    <div class="token-item">
                        <div class="token-info">
                            <div class="token-label">${escapeHtml(token.label)}</div>
                            <div class="token-value" onclick="copyToClipboard('${token.token}')" title="Click to copy">${token.token}</div>
                            <div class="token-meta">
                                Created: ${createdDate} | Last used: ${lastSeenDate} | Usage: ${usageCount} requests
                            </div>
                        </div>
                        <div class="token-actions">
                            <span class="token-status ${token.active ? 'active' : 'inactive'}">
                                ${token.active ? 'Active' : 'Inactive'}
                            </span>
                            <button onclick="copySnippet('${token.token}', '${escapeHtml(token.label)}')" class="btn-primary">
                                Copy Snippet
                            </button>
                            <button onclick="toggleToken(${token.id}, ${!token.active})" class="btn-secondary">
                                ${token.active ? 'Deactivate' : 'Activate'}
                            </button>
                            <button onclick="deleteToken(${token.id}, '${escapeHtml(token.label)}')" class="btn-danger">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function addTrackingToken(event) {
            event.preventDefault();
            const button = event.target.querySelector('button[type="submit"]');
            const formData = new FormData(event.target);
            const label = formData.get('label').trim();

            if (!label) {
                showTokensMessage('Label is required', 'error');
                return;
            }

            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Creating...';

            try {
                const response = await apiFetch('/ingest/tokens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ label })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                showTokensMessage(`Tracking token "${label}" created successfully!`, 'success');
                event.target.reset();
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error adding tracking token:', error);
                showTokensMessage(`Failed to create token: ${error.message}`, 'error');
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        async function toggleToken(tokenId, newActiveState) {
            try {
                const response = await apiFetch(`/ingest/tokens/${tokenId}/active`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ active: newActiveState })
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                const action = newActiveState ? 'activated' : 'deactivated';
                showTokensMessage(`Token ${action} successfully`, 'success');
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error toggling token:', error);
                showTokensMessage(`Failed to toggle token: ${error.message}`, 'error');
            }
        }

        async function deleteToken(tokenId, label) {
            if (!confirm(`Are you sure you want to delete the tracking token "${label}"? This action cannot be undone.`)) {
                return;
            }

            try {
                const response = await apiFetch(`/ingest/tokens/${tokenId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.message || `HTTP ${response.status}`);
                }

                showTokensMessage(`Token "${label}" deleted successfully`, 'success');
                await fetchTrackingTokens();

            } catch (error) {
                console.error('Error deleting token:', error);
                showTokensMessage(`Failed to delete token: ${error.message}`, 'error');
            }
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showTokensMessage('Token copied to clipboard!', 'success');
                }).catch(() => {
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }

        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                showTokensMessage('Token copied to clipboard!', 'success');
            } catch (err) {
                showTokensMessage('Failed to copy token', 'error');
            }
            document.body.removeChild(textArea);
        }

        function copySnippet(token, label) {
            openSnippetsModal(token, label);
        }

        function showTokensMessage(message, type = 'info') {
            const messageEl = document.getElementById('tokens-message');
            messageEl.textContent = message;
            messageEl.className = `tokens-message ${type}`;
            
            // Hide message after 5 seconds
            setTimeout(() => {
                messageEl.className = 'tokens-message hidden';
            }, 5000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Usage snippets modal functionality
        function openSnippetsModal(token, label) {
            const modal = document.getElementById('snippets-modal');
            
            // Replace placeholders with actual values in all code blocks
            updateSnippetContent(token);
            
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent background scroll
        }

        function closeSnippetsModal() {
            const modal = document.getElementById('snippets-modal');
            modal.classList.add('hidden');
            document.body.style.overflow = ''; // Restore scrolling
        }

        function switchTab(tabName) {
            // Update tab buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const activeButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (activeButton) activeButton.classList.add('active');
            
            // Update tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            const activeContent = document.getElementById(`${tabName}-tab`);
            if (activeContent) activeContent.classList.add('active');
        }

        function updateSnippetContent(token) {
            const baseUrl = window.location.origin;
            
            // Update cURL examples
            const curlBasic = document.getElementById('curl-basic');
            if (curlBasic) {
                curlBasic.textContent = `curl -X POST "${baseUrl}/ingest" \\
  -H "Content-Type: application/json" \\
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \\
  -d '{
    "tracking_token": "${token}",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "cost_usd": 0.002250
  }'`;
            }

            const curlIdempotent = document.getElementById('curl-idempotent');
            if (curlIdempotent) {
                curlIdempotent.textContent = `curl -X POST "${baseUrl}/ingest" \\
  -H "Content-Type: application/json" \\
  -H "X-Ingest-Key: YOUR_INGEST_KEY" \\
  -d '{
    "tracking_token": "${token}",
    "event_id": "unique-event-123",
    "model": "gpt-4o-mini-2024-07-18",
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150,
    "cost_usd": 0.002250,
    "timestamp": "2024-01-15T10:30:00Z"
  }'`;
            }

            // Update Python examples
            const pythonBasic = document.getElementById('python-basic');
            if (pythonBasic) {
                pythonBasic.textContent = `import requests
import json
from datetime import datetime, timezone

def log_openai_usage(tracking_token, model, prompt_tokens, completion_tokens, cost_usd, event_id=None):
    """Log OpenAI usage to Cost Guardian"""
    
    payload = {
        "tracking_token": tracking_token,
        "model": model,
        "prompt_tokens": prompt_tokens,
        "completion_tokens": completion_tokens,
        "cost_usd": cost_usd,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    if event_id:
        payload["event_id"] = event_id
    
    response = requests.post(
        "${baseUrl}/ingest",
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": "YOUR_INGEST_KEY"
        },
        json=payload
    )
    
    if response.status_code == 201:
        print("Usage logged successfully")
    elif response.status_code == 200:
        result = response.json()
        if result.get("duplicate"):
            print("Duplicate event ignored (idempotency)")
    else:
        print(f"Error logging usage: {response.status_code} - {response.text}")

# Example usage
log_openai_usage(
    tracking_token="${token}",
    model="gpt-4o-mini-2024-07-18",
    prompt_tokens=100,
    completion_tokens=50,
    cost_usd=0.002250,
    event_id="unique-event-123"  # Optional for idempotency
)`;
            }

            const pythonOpenai = document.getElementById('python-openai');
            if (pythonOpenai) {
                pythonOpenai.textContent = `import openai
import requests
from datetime import datetime, timezone

# Configure OpenAI and Cost Guardian
openai.api_key = "your-openai-api-key"
COST_GUARDIAN_URL = "${baseUrl}/ingest"
INGEST_KEY = "YOUR_INGEST_KEY"
TRACKING_TOKEN = "${token}"

def chat_with_logging(messages, model="gpt-4o-mini-2024-07-18"):
    """Make OpenAI chat completion and log usage to Cost Guardian"""
    
    # Make OpenAI request
    response = openai.chat.completions.create(
        model=model,
        messages=messages
    )
    
    # Extract usage information
    usage = response.usage
    
    # Log to Cost Guardian
    log_payload = {
        "tracking_token": TRACKING_TOKEN,
        "model": model,
        "prompt_tokens": usage.prompt_tokens,
        "completion_tokens": usage.completion_tokens,
        "total_tokens": usage.total_tokens,
        "cost_usd": calculate_cost(usage, model),  # Implement your cost calculation
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "event_id": response.id  # Use OpenAI response ID for idempotency
    }
    
    requests.post(
        COST_GUARDIAN_URL,
        headers={
            "Content-Type": "application/json",
            "X-Ingest-Key": INGEST_KEY
        },
        json=log_payload
    )
    
    return response

def calculate_cost(usage, model):
    """Calculate cost based on OpenAI pricing"""
    # Example pricing for gpt-4o-mini-2024-07-18
    prompt_cost_per_1k = 0.000150
    completion_cost_per_1k = 0.000600
    
    prompt_cost = (usage.prompt_tokens / 1000) * prompt_cost_per_1k
    completion_cost = (usage.completion_tokens / 1000) * completion_cost_per_1k
    
    return prompt_cost + completion_cost`;
            }

            // Update Node.js examples
            const nodejsBasic = document.getElementById('nodejs-basic');
            if (nodejsBasic) {
                nodejsBasic.textContent = `async function logOpenAIUsage(trackingToken, model, promptTokens, completionTokens, costUsd, eventId = null) {
  const payload = {
    tracking_token: trackingToken,
    model: model,
    prompt_tokens: promptTokens,
    completion_tokens: completionTokens,
    cost_usd: costUsd,
    timestamp: new Date().toISOString()
  };

  if (eventId) {
    payload.event_id = eventId;
  }

  try {
    const response = await fetch("${baseUrl}/ingest", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": "YOUR_INGEST_KEY"
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.status === 201) {
      console.log("Usage logged successfully");
    } else if (response.status === 200 && data.duplicate) {
      console.log("Duplicate event ignored (idempotency)");
    } else {
      console.error(\`Error logging usage: \${response.status}\`, data);
    }
  } catch (error) {
    console.error("Failed to log usage:", error);
  }
}

// Example usage
await logOpenAIUsage(
  "${token}",
  "gpt-4o-mini-2024-07-18",
  100,
  50,
  0.002250,
  "unique-event-123"  // Optional for idempotency
);`;
            }

            const nodejsOpenai = document.getElementById('nodejs-openai');
            if (nodejsOpenai) {
                nodejsOpenai.textContent = `import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: 'your-openai-api-key'
});

const COST_GUARDIAN_URL = "${baseUrl}/ingest";
const INGEST_KEY = "YOUR_INGEST_KEY";
const TRACKING_TOKEN = "${token}";

async function chatWithLogging(messages, model = "gpt-4o-mini-2024-07-18") {
  try {
    // Make OpenAI request
    const response = await openai.chat.completions.create({
      model: model,
      messages: messages
    });

    // Extract usage information
    const usage = response.usage;

    // Log to Cost Guardian
    const logPayload = {
      tracking_token: TRACKING_TOKEN,
      model: model,
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
      total_tokens: usage.total_tokens,
      cost_usd: calculateCost(usage, model),
      timestamp: new Date().toISOString(),
      event_id: response.id  // Use OpenAI response ID for idempotency
    };

    await fetch(COST_GUARDIAN_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Ingest-Key": INGEST_KEY
      },
      body: JSON.stringify(logPayload)
    });

    return response;
  } catch (error) {
    console.error("Error in chat with logging:", error);
    throw error;
  }
}

function calculateCost(usage, model) {
  // Example pricing for gpt-4o-mini-2024-07-18
  const promptCostPer1k = 0.000150;
  const completionCostPer1k = 0.000600;
  
  const promptCost = (usage.prompt_tokens / 1000) * promptCostPer1k;
  const completionCost = (usage.completion_tokens / 1000) * completionCostPer1k;
  
  return promptCost + completionCost;
}

// Example usage
const messages = [
  { role: "user", content: "Hello, how are you?" }
];

const response = await chatWithLogging(messages);
console.log(response.choices[0].message.content);`;
            }
        }

        function copyCodeBlock(button) {
            const codeBlock = button.parentElement;
            const preElement = codeBlock.querySelector('pre');
            const text = preElement.textContent;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.textContent;
                    button.textContent = 'Copied!';
                    button.style.background = '#28a745';
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#007cba';
                    }, 2000);
                }).catch(() => {
                    fallbackCopyCodeBlock(text, button);
                });
            } else {
                fallbackCopyCodeBlock(text, button);
            }
        }

        function fallbackCopyCodeBlock(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = '#28a745';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#007cba';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy code block:', err);
            }
            
            document.body.removeChild(textArea);
        }

        // Close modal on click outside or Escape key
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('snippets-modal');
            if (e.target === modal) {
                closeSnippetsModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('snippets-modal');
            const isModalVisible = !modal.classList.contains('hidden');
            
            if (e.key === 'Escape' && isModalVisible) {
                closeSnippetsModal();
            }
        });

        // Filtering functions
        function getCurrentFilters() {
            const preset = document.getElementById('range-select').value;
            const model = document.getElementById('model-select').value;

            if (preset === 'custom') {
                const sd = document.getElementById('start-date').value;
                const ed = document.getElementById('end-date').value;
                if (sd && ed) {
                    return { start: toISOStartOfDay(sd), end: toISOEndOfDay(ed), model };
                }
                return { model }; // no date filtering until both provided
            } else {
                const { start, end } = computePresetRange(preset);
                return { start, end, model };
            }
        }

        function onPresetChange() {
            const preset = document.getElementById('range-select').value;
            const customWrap = document.getElementById('custom-date-wrap');
            customWrap.style.display = preset === 'custom' ? 'flex' : 'none';
            if (preset !== 'custom') {
                // Save filter preference
                localStorage.setItem('cg_date_preset', preset);
                fetchData(getCurrentFilters());
            }
        }

        // Debounced model change handler
        let modelChangeTimeout;
        function onModelChange() {
            clearTimeout(modelChangeTimeout);
            modelChangeTimeout = setTimeout(() => {
                localStorage.setItem('cg_model_filter', document.getElementById('model-select').value);
                fetchData(getCurrentFilters());
            }, 150);
        }

        function onDateChange() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            if (startDate && endDate) {
                fetchData(getCurrentFilters());
            } else if (startDate || endDate) {
                // Show hint when only one date is selected
                const message = startDate ? 'Please select an end date' : 'Please select a start date';
                renderTableMessage(message);
            }
        }

        // Load models from server for stable dropdown
        async function loadModels() {
            try {
                const response = await apiFetch('/models');
                if (response.ok) {
                    const data = await response.json();
                    const select = document.getElementById('model-select');
                    const currentValue = select.value;
                    
                    const opts = ['<option value="all">All Models</option>'].concat(
                        data.models.map(m => `<option value="${m}">${m}</option>`)
                    );
                    select.innerHTML = opts.join('');
                    
                    // Restore saved model filter
                    const savedModel = localStorage.getItem('cg_model_filter');
                    if (savedModel && [...select.options].some(o => o.value === savedModel)) {
                        select.value = savedModel;
                    } else if (currentValue && [...select.options].some(o => o.value === currentValue)) {
                        select.value = currentValue;
                    }
                }
            } catch (error) {
                console.error('Failed to load models:', error);
                // Fallback to populating from current data
            }
        }

        // Set up event listeners
        document.getElementById('add-key-form').addEventListener('submit', addKey);
        document.getElementById('add-token-form').addEventListener('submit', addTrackingToken);

        // Filter event listeners
        document.getElementById('range-select').addEventListener('change', onPresetChange);
        document.getElementById('model-select').addEventListener('change', onModelChange);
        document.getElementById('apply-filters').addEventListener('click', () => fetchData(getCurrentFilters()));
        document.getElementById('start-date').addEventListener('change', onDateChange);
        document.getElementById('end-date').addEventListener('change', onDateChange);

        // Initialize on page load
        async function initialize() {
            // Set up default filters from localStorage or defaults
            const savedPreset = localStorage.getItem('cg_date_preset') || 'this_month';
            const savedModel = localStorage.getItem('cg_model_filter') || 'all';
            
            document.getElementById('range-select').value = savedPreset;
            document.getElementById('model-select').value = savedModel;
            
            // Show/hide custom date inputs based on preset
            const customWrap = document.getElementById('custom-date-wrap');
            customWrap.style.display = savedPreset === 'custom' ? 'flex' : 'none';
            
            const existingKey = getApiKey();
            
            if (existingKey) {
                // Try to authenticate with existing key
                updateAuthStatus(existingKey);
                try {
                    // Load data, keys, tokens, and models in parallel
                    await Promise.all([
                        fetchData(getCurrentFilters()),
                        fetchKeys(),
                        fetchTrackingTokens(),
                        loadModels()
                    ]);
                } catch (error) {
                    // Existing key invalid, clear it
                    clearApiKey();
                    updateAuthStatus('');
                    showLogin('Your session has expired. Please sign in again.');
                }
            } else {
                // No key - try fetching data to see if auth is required
                try {
                    await Promise.all([
                        fetchData(getCurrentFilters()),
                        fetchKeys(),
                        fetchTrackingTokens(),
                        loadModels()
                    ]);
                } catch (error) {
                    if (error.message === 'Unauthorized') {
                        showLogin();
                    }
                }
            }
        }

        // Start the app
        initialize();
    </script>
</body>
</html>